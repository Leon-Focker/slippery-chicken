<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>slippery chicken documentation - chord functions</title>
    <!-- change the following two file paths to be ../ if in a subdirectory -->
    <link href="../sc-stylesheet.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="../head-foot.js"></script>
    <script language="javascript" type="text/javascript"
            src="../show-hide.js"></script>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>
  
  <body onload="showHide(window.location.hash.substring(1)+'-div')" >
    <div id="content">
      <!-- files in the doc directory will call header with argument "./" but
           those in subdirectories will need "../" -->
      <script type="text/javascript">header("../");</script>
      <noscript>Your browser does not support JavaScript!</noscript>
      <!-- **************************************************************** -->
      
      <h2>Chord functions</h2>

      <h3 id="files"><a href="#files" id="files-div-show"
                        onclick="showHide('files-div');return false;">+</a>
        Associated example files</h3>
      <div id="files-div" class="more">
        <ul>
          <li><a href="../examples/chords-examples.lsp">chords-examples.lsp</a></li>
        </ul>
        <p class="close"><a href="#" id="files-div-hide" class="hideLink"
              onclick="showHide('files-div');return false;">close</a></p>
        <br />
      </div>

      <h3 id="prep"><a href="#prep" id="prep-div-show"
                       onclick="showHide('prep-div');return false;">+</a>
        Preparing instruments for playing chords</h3>
      <div id="prep-div" class="more">
        <p>The user can indicate that <em>slippery chicken</em> is to place an
          automatically generated chord at a given point in the piece by
          enclosing the corresponding number from the <code>pitch-seq</code>
          curve in parentheses. </p>
        
        <pre class="source">
:pitch-seq-palette ((1 (3) 2 3 (5) 4 6 3))</pre>

        <p>When <em>slippery chicken</em> encounters a <code>pitch-seq</code>
          number in parentheses, it first checks to see whether the given
          instrument is capable of playing chords. An instrument can be
          designated as able to play chords by setting the <code>chords</code>
          slot to <code>T</code> in the definition of
          the <code>instrument</code> object, as seen here:</p>

        <pre class="source">
(piano
 (:staff-name "piano" :staff-short-name "pno"
  :lowest-written a0 :highest-written c8 
  :clefs (treble bass double-treble double-bass) :starting-clef treble
  :chords t :chord-function piano-chord-fun
  :largest-fast-leap 9
  :microtones nil 
  :midi-program 1))</pre>

        <p>If an instrument is able to play chords, <em>slippery chicken</em>
          requires a chord-generating function that determines how pitches are
          selected from the current set when making chords for that
          instrument. The user can specify which chord-generating function
          <em>slippery chicken</em> is to use for the given instrument by
          passing the variable to which that function is assigned to
          the <code>chord-function</code> slot of the
          given <code>instrument</code> object, as seen above.</p>

        <p class="close"><a href="#" id="prep-div-hide" class="hideLink"
              onclick="showHide('prep-div');return false;">close</a></p>
      </div>

      <h3 id="default"><a href="#default" id="default-div-show"
                          onclick="showHide('default-div');return false;">+</a>
        The default-chord-function</h3>
      <div id="default-div" class="more">
        <p>If the <code>chords</code> slot is set to <code>T</code> but
          the <code>chord-function</code> is left unspecified,
          <em>slippery chicken</em> will select the pitches for that
          instrument's chords using
          the <a href="../robodoc/instrument_lsp.html#instrument2fdefault2dchord2dfunction"><code>default-chord-function</code></a>,
          as defined in the <code>instrument</code> class.</p>

        <p>The <code>default-chord-function</code> generates two-note chords
          consisting of the pitch that would be generated by the number in
          parentheses in the <code>pitch-seq</code> curve and the next lower
          pitch from the set that is available to the instrument
          at that time. If no lower pitches are available, the function chooses
          the next higher pitch instead. If neither of these options can be
          fulfilled, it returns the original single pitch.</p>

        <p>Using the <code>default-chord-function</code> with
          the <code>vibraphone</code> of
          the <code>+slippery-chicken-standard-instrument-palette+</code> and
          the following <code>set-palette</code>, <code>rthm-seq</code> and
          associated <code>pitch-seq</code>:</p>

        <pre class="source">
:set-palette '((1 ((c4 d4 e4 f4 g4 a4 b4 c5))))
:rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                        :pitch-seq-palette ((1 (2) 3 4 (5) (6) (7) 8)))))</pre>

        <p>&hellip;produces the following printable output:</p>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-default.png"
                       alt="chords-default.png" width="266"/></td></tr>
        </table>

        <p class="close"><a href="#" id="default-div-hide" class="hideLink"
              onclick="showHide('default-div');return false;">close</a></p>
      </div>
      
      <h3 id="pre-defined"><a href="#pre-defined" id="pre-defined-div-show"
                               onclick="showHide('pre-defined-div');return
                               false;">+</a> 
        Predefined chord functions</h3>
      <div id="pre-defined-div" class="more">
        <p>A number of chord functions have been predefined in the
        <!-- MDE Thu May 17 17:45:27 2012 -- can't refer to src code as it
        won't be on the web --> file instruments.lsp and are loaded
        automatically with <em>slippery chicken</em>. Some of the
        <code>instrument</code> objects in the <a
         href="../robodoc/instruments_lsp.html#instruments2f2bslippery2dchicken2dstandard2dinstrument2dpalette2b"><code>+slippery-chicken-standard-instrument-palette+</code></a>
        already make use of these functions, including the <code>piano</code>,
        <code>guitar</code>, <code>violin</code>, <code>viola</code>, and
        <code>cello</code> objects. </p>
        
        <h4 id="pno-chrd-fun">The piano-chord-fun</h4>
        <p>The definition of the <code>piano</code> instrument object in the
          <a href="#prep" onclick="jumpShow('prep-div')">preparing instruments
          for playing chords</a> section above, for example, indicates
          that <em>slippery chicken</em> is to use
          the <code>piano-chord-fun</code>. That function generates four-note
          chords from consecutive notes in the current set, where possible,
          with the number enclosed in parentheses in the <code>pitch-seq</code>
          being the top note of that chord, where possible.</p>

        <p>Using the <code>piano-chord-fun</code> with the <code>piano</code>
          of the <code>+slippery-chicken-standard-instrument-palette+</code>
          and the following <code>set-palette</code>, <code>rthm-seq</code> and
          associated <code>pitch-seq</code>:</p>

        <pre class="source">
:set-palette '((1 ((c4 d4 e4 f4 g4 a4 b4 c5))))
:rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                        :pitch-seq-palette ((1 (2) 3 4 (5) (6) (7) 8)))))</pre>

        <p>&hellip;produces the following printable output:</p>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img  src="./resources/chords-piano.png"
                        alt="chords-piano.png" width="244" /></td></tr>
        </table>
        <br />
        
        <p class="nb">NB: The major-second clusters in the above example are
          the result of this function being applied to a set consisting of only
          major seconds. If the consecutive pitches in the set were to have
          larger intervals between them, the resulting chords would reflect
          this in their interval structure.</p>

        <h4 id="chord-fun1-2">The chord-fun1 and chord-fun2 functions</h4>
        <p>Two other basic predefined chord functions,
          namely <code>chord-fun1</code> and <code>chord-fun2</code>, can also
          be found at the bottom of the <code>instruments.lsp</code> file.</p>
        
        <p>None of the <code>instrument</code> objects in
          the <code>+slippery-chicken-standard-instrument-palette+</code> use
          either of these functions by default. The user can choose to use one
          of these as the chord function for a given instrument by setting the
          corresponding <code>instrument</code>
          object's <code>chord-function</code> slot using
          the <code>set-slot</code> method (see the section
          on <a href="instruments.html#changing">changing instrument attributes
          temporarily</a> for more detail): </p>

        <pre class="source">
(set-slot 'chord-function
          'chord-fun1
          'piano
          +slippery-chicken-standard-instrument-palette+)</pre>

        <p>The <code>chord-fun1</code> function generates three-note chords
          where possible, using every second pitch from the list of pitches
          currently available to the given instrument from the current set and
          ensuring that none of the chords it makes span more than an
          octave. </p>

        <p>Using the <code>chord-fun1</code> function with
          the <code>piano</code> of
          the <code>+slippery-chicken-standard-instrument-palette+</code> and
          the following <code>set-palette</code>, <code>rthm-seq</code> and
          associated <code>pitch-seq</code>:</p>

        <pre class="source">
:set-palette '((1 ((c4 d4 e4 f4 g4 a4 b4 c5))))
:rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                        :pitch-seq-palette ((1 (2) 3 4 (5) (6) (7) 8)))))</pre>

        <p>&hellip;produces the following printable output:</p>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-chord-fun1.png"
               alt="chords-chord-fun1.png" width="245"/></td></td>
        </table>
        <br />
        
        <p>The <code>chord-fun2</code> function generates 4-note chords where
          possible, using every third pitch from the list of pitches currently
          available to the given instrument from the current set, with no limit
          on the total span of the chord.</p>

        <p>Using the <code>chord-fun2</code> function with
          the <code>piano</code> of
          the <code>+slippery-chicken-standard-instrument-palette+</code> and
          the following <code>set-palette</code>, <code>rthm-seq</code> and
          associated <code>pitch-seq</code>:</p>

        <pre class="source">
:set-palette '((1 ((c4 d4 e4 f4 g4 a4 b4 c5 d5 e5 f5 g5 a5 b5 c6 d6 e6))))
:rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                        :pitch-seq-palette ((1 (3) 5 7 (11) (13) (15) 17)))))</pre>

        <p>&hellip;produces the following printable output:</p>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-chord-fun2.png"
                       alt="chords-chord-fun2.png" width="246"/></td></tr>
        </table>
        <br />
        
        <p>These two functions make use of the <code>chord-fun-aux</code>
          function, which can be very handy for users who want to create
          moderately tailored chord selection functions with only a few
          standard arguments, as is described in more detail below. </p>

        <p class="close"><a href="#" id="pre-defined-div-hide" class="hideLink"
              onclick="showHide('pre-defined-div');return
              false;">close</a></p>
      </div>

      <h3 id="user-defined">User-defined chord functions</h3>
      <h4 id="chord-aux"><a href="#chord-aux" id="chord-aux-div-show"
                            onclick="showHide('chord-aux-div'); return
                            false;">+</a> 
        The chord-fun-aux function</h4>
      <div id="chord-aux-div" class="more">
        <p>The <code>chord-aux-fun</code> is a function that can be used to
          create moderately tailored, user-defined chord functions.</p>

        <h5>The arguments</h5>
        <p>All internal pitch-selection processes in <em>slippery chicken</em>
          require the arguments <code>curve-num</code>, <code>index</code>,
          <code>pitch-list</code>, <code>pitch-seq</code>, 
          <code>instrument</code>, and set. For that reason, all user-defined
          chord functions must also start by specifying these arguments but they
          can safely be ignored and very often are even by <em>slippery
          chicken's</em> chord functions (they are passed for the sake of
          completeness). <code>default-chord-fun</code> describes/uses these
          arguments as follows:
        <ol>
          <li>The current number from the pitch-seq. Currently ignored by
          default.
          <li>The index that the first argument was translated into by the
            offset and scaler (based on trying to get a best fit for the
            instrument and set).  This can be assumed to be a legal reference
            into pitch-list as it was calculated as fitting in
            <code>pitch-seq's get-notes</code>.  (zero-based.) </li>
          <li>The pitch-list created from the set, taking into account the
            instrument's range and other notes already played by other
            instruments.</li>
          <li>The current pitch-seq object. Currently ignored by default.</li>
          <li>The current instrument object. Currently ignored by default.</li>
          <li>The current set object. Currently ignored by default.</li>
          </ol>

        <pre class="source">
(defun new-chord-function (curve-num index pitch-list pitch-seq instrument set)&hellip;</pre>

        <p>The <code>chord-fun-aux</code> function adds three new arguments to
          this list, namely <code>skip</code>, <code>num-notes</code>,
          and <code>max-span</code>: </p>

        <pre class="source">
(defun chord-fun-aux (curve-num index pitch-list pitch-seq instrument set
                      skip num-notes max-span)&hellip;</pre>

        <p>All three arguments take integers as their values.</p> 

        <p>The <code>chord-fun-aux</code> is designed to collect pitches from
          the segment of the current set that is available to an instrument
          when the chord is made (i.e. the <code>pitch-list</code> argument) by
          passing consecutively through each pitch of that list. The
          <code>skip</code> argument allows the user to design functions that
          skip some of these notes. Setting this argument to <code>1</code>
          results in no pitches being skipped and chords being created from
          consecutive pitches in the <code>pitch-list</code>. A value
          of <code>2</code> for this argument takes every second pitch from the
          segment of the set, a value of <code>3</code> every third, etc.
          Thus, if the pitches available to an instrument at a given moment
          are <code>(C4 E4 F4 A4 B4 D5)</code>, and <code>skip</code> is set
          to <code>2</code>, a three-note chord starting on <code>C4</code>
          will be made from pitches <code>(C4 F4 B4)</code>. </p>

        <p>The argument <code>num-notes</code> determines the number of pitches
          the function will try to place in each chord. If the list of pitches
          available to an instrument is too short to make a chord
          with <em><code>x</code></em> notes, a chord with fewer pitches may be
          made instead.</p>

        <p>The <code>max-span</code> argument designates the largest interval
          (in semitones) allowed between the bottom and top notes of the
          chord. If a chord made with the specified number of notes surpasses
          this span, a chord with fewer pitches may be made instead.</p>

        <h5>Making a new chord function using chord-fun-aux</h5>
        <p>New chord functions based on <code>chord-fun-aux</code> are made
          using the usual Lisp <code>defun</code> macro.</p>

        <pre class="source">
(defun new-chord-function (curve-num index pitch-list pitch-seq instrument set)
  (chord-fun-aux curve-num index pitch-list pitch-seq instrument set 4 3 14))</pre>

        <p>Any user-defined chord function must be defined before
          the <code>slippery-chicken</code> object is made, so that
          the <code>make-slippery-chicken</code> function knows how to choose
          the pitches for the chords.</p>

        <p>The user first specifies the name of the new function and lists the
          six arguments required for all note functions mentioned above. In the
          body of the new function, the user then calls
          <code>chord-fun-aux</code>, listing the first six arguments again
          and specifying integer values for the three new arguments.</p>
        
        <p>For example, the <code>new-chord-function</code> defined above
          creates a new function that makes chords from every fourth pitch in
          the segment of the current set that is available to the instrument,
          aiming to make three-note chords where possible, with a maximum span
          of 14 semitones between the bottom and top note of the chord.</p>
        
        <p>Applying this function to the <code>piano</code> instrument of
          the <code>+slippery-chicken-standard-instrument-palette+</code> with
          the following <code>set-palette</code>, <code>rthm-seq</code>, and
          associated <code>pitch-seq</code>:</p>
        
        <pre class="source">
:set-palette '((1 ((c4 d4 e4 f4 g4 a4 b4 
                    c5 d5 e5 f5 g5 a5 b5))))
:rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                        :pitch-seq-palette ((1 (14) (13) (12) 11 10 9 8))))) </pre>

        <p>&hellip;produces the following printable output:</p>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-new-fun.png"
                       alt="chords-new-fun.png" width="233"/></td></td>
        </table>
        <br />
        
        <p class="close"><a href="#" id="chord-aux-div-hide" class="hideLink"
              onclick="showHide('chord-aux-div');return false;">close</a></p>
      </div>

      <h4 id="breakdown"><a href="#breakdown" id="breakdown-div-show"
                            onclick="showHide('breakdown-div'); return
                                     false;">+</a> 
        A breakdown of the chord-fun-aux function</h4>
      <div id="breakdown-div" class="more">
        <p>Since <em>slippery chicken</em> provides users with the flexibility
          of defining their own chord selection functions, an introduction to
          how a fully separate chord function may be programmed is given here
          by examining the <code>chord-fun-aux</code> function in more
          detail. </p>

        <pre class="source">
(defun chord-fun-aux (curve-num index pitch-list pitch-seq instrument set
                      skip num-notes max-span)
  (declare (ignore set instrument pitch-seq curve-num))
  (unless (and (integer&gt;0 skip) (integer&gt;0 num-notes) (integer&gt;0 max-span))
    (error "slippery-chicken::instruments:: skip, num-notes, and max-span must
            be integers > 0"))
  (let* ((start (max 0 (- index (- (* skip num-notes) skip))))
         (at-start (nth start pitch-list))
         (result (list at-start)))
    (loop 
       repeat num-notes
       for i from start by skip
       for p = (nth i pitch-list)
       do
         (when (and p 
                    (&lt;= (pitch- p at-start) max-span)
                    (not (member p result :test #'note=)))
           (push p result)))
    (if (&gt; (length result) 1)
        (make-chord result)
        (first result))))</pre>
        
        <p>All chord functions must be defined with the same six required
          arguments:</p>
        
        <pre class="source">
(defun chord-fun-aux (curve-num index pitch-list pitch-seq instrument set</pre>

        <p><code>chord-fun-aux</code> adds three more arguments to this
          list:</p>
        
        <pre class="source">
                      skip num-notes max-span)</pre>
        
        <p>Not all of the arguments must be used (see
          the <a href="../robodoc/instrument_lsp.html#instrument2fdefault2dchord2dfunction"><code>default-chord-function</code></a>
          page for details on the arguments). Common Lisp will print
          a <code>WARNING</code> by default for any arguments that aren't
          used. These warnings can be suppressed by using
          the <code>declare</code> and <code>ignore</code> functions with the
          unused arguments:</p>

        <pre class="source">
  (declare (ignore set instrument pitch-seq curve-num))</pre>

        <p>In addition to its three new arguments, the only required arguments
          this function makes use of are <code>index</code>
          and <code>pitch-list</code>. The <code>pitch-list</code> is the
          automatically generated sublist of pitches from the current set that
          are available to the instrument at that point in the piece. This is
          different from the <code>set</code> argument, which gives the user
          access to all of the pitches in the current set, regardless of any
          limiting factors. (See the documentation
          on <a href="./pitches.html#selection">how <em>slippery chicken</em>
          selects pitches</a> for more detail.) The value of
          the <code>index</code> argument is also determined internally
          by <em>slippery chicken</em> as part of the automatic pitch selection
          process. It refers to a pitch within the <code>pitch-list</code>.</p>

        <p>The function then tests to make sure that the user hasn't passed a
          value of <code>0</code> to any of the three new arguments, and exits
          with an error if any of these values are <code>0</code>:</p>

        <pre class="source">
  (unless (and (integer&gt;0 skip) (integer&gt;0 num-notes) (integer&gt;0 max-span))
    (error "slippery-chicken::instruments:: skip, num-notes, and max-span must
            be integers > 0"))</pre>

        <p>Three variables are then declared for the function. The
          first, <code>start</code>, determines the index number for the first
          pitch in the chord.</p>

        <pre class="source">
  (let* ((start (max 0 (- index (- (* skip num-notes) skip))))</pre>

        <p>It does so in four concise steps: It first multiplies the
          <code>skip</code> value by the <code>num-notes</code> value and then
          subtracts the <code>skip</code> value from the result to get the
          ideal index for the highest note in the chord. It then subtracts that
          result from the value of the <code>index</code> argument to get the
          ideal index for the lowest note of the chord, since the
          <code>index</code> number is to be for the top note of the chord. Its
          last step is to compare this result with <code>0</code> and choose
          the higher value, so as not to generate an illegal (i.e. less than
          zero) reference into a list. That value is the index of the first
          (lowest) note in the chord.</p>

        <p>The second variable is for the first pitch itself. It gets the pitch
          located at the position <code>start</code> in
          the <code>pitch-list</code> and assigns it to the
          variable <code>at-start</code>:</p>

        <pre class="source">
         (at-start (nth start pitch-list))</pre>

        <p>The final variable, <code>result</code>, is for the list of pitches
          that will make up the chord. This list is initiated with just the
          first single pitch of the <code>at-start</code> variable, and will be
          expanded by new pitches as the function takes its course: </p>

        <pre class="source">
         (result (list at-start)))</pre>

        <p>The function then begins a <code>loop</code> that is to repeat the
          number of times specified by the value
          of <code>num-notes</code>: </p>

        <pre class="source">
    (loop 
       repeat num-notes</pre>

        <p>The first time through the loop the value of <code>i</code> is set
          to the value of <code>start</code>. Each successive time through the
          loop it increases the value of <code>i</code> by the value assigned
          to the <code>skip</code> variable:</p>

        <pre class="source">
       for i from start by skip</pre>

        <p>Each time through the loop it sets the variable <code>p</code> to
          the pitch located at position <code>i</code> in
          the <code>pitch-list</code>:</p>

        <pre class="source">
       for p = (nth i pitch-list)</pre>

        <p>For each pitch <code>p</code> it runs three tests. It first checks
          to make sure that <code>p</code> indeed has a value (is
          not <code>NIL</code>); then it checks to see if the result of
          subtracting the <code>at-start</code> pitch from <code>p</code>
          (using the method <code>pitch-</code>) returns a number (semitones)
          less than or equal to the value of <code>max-span</code>; and finally
          it checks to see that pitch <code>p</code> is not already present in
          the <code>result</code> list.  When all of these conditions are met,
          it adds <code>p</code> to the <code>result</code> list:</p>

        <pre class="source">
       do
         (when (and p 
                    (&lt;= (pitch- p at-start) max-span)
                    (not (member p result :test #'note=)))
           (push p result)))    </pre>

        <p>Now that the pitches have been collected and added to
          the <code>result</code> list, the method first double-checks to make
          sure that the <code>result</code> list has more than one pitch in
          it. As long as this is the case, the function creates a chord from
          the pitches in the <code>result</code> list using
          the <code>make-chord</code> function. If the <code>result</code> list
          has only one pitch in it, the function just returns that single
          pitch. </p>

        <pre class="source">
    (if (> (length result) 1)
        (make-chord result)
        (first result))))</pre>

        <p>This provides a powerful approach to algorithmically generating
          chords as chord selection for a whole piece can be refined through
          careful management of one simple function.  For example,
          in <a href="http://sumtone.com/work.php?workid=307"><i>you are coming
          into us who cannot withstand you</i></a> by Michael Edwards, the
          muddiness created by the default piano chord, which selected low
          minor thirds and major sevenths, was avoided
          by <a href="../examples/coming-piano-chords.lsp">modifying the
          piano chord selection function</a> to select fourths when below a
          certain pitch.  In this way the harmonic character of the piano in
          the whole piece could be changed in one fell swoop.</p>

        <p class="close"><a href="#" id="breakdown-div-hide" class="hideLink"
              onclick="showHide('breakdown-div');return false;">close</a></p>
      </div>
      
      <h4>Chord functions and set-palette subsets</h4>
      <h5 id="ss-fun-1"><a href="#ss-fun-1" id="ss-fun-1-div-show"
                           onclick="showHide('ss-fun-1-div');return
                           false;">+</a> 
        Example 1&mdash;One subset chord per set</h5>
      <div id="ss-fun-1-div" class="more">
        <p>One possible approach to writing user-defined chord functions
          without the use of the <code>chord-fun-aux</code> is to
          define <code>subsets</code> (and/or <code>related-sets</code>) in the
          sets that are accessed by the function to create chords. This can be
          done <em>without</em> the use of a <code>subset-id</code> in the
          corresponding <code>instrument</code> object, since any user-defined
          function can have access to the entire set, as described above. The
          examples here employ that approach. (More information on how to use
          an <code>instrument</code> object's <code>subset-id</code> slot can
          be found on the <a href="./pitches.html#subset-id">pitches</a>
          page.) </p>

        <p>One option could be to define one single chord that is to be used
          any time a chord indication is encountered for a given set. As
          mentioned in the section on <code>chord-fun-aux</code> above, any
          chord function must be defined before
          the <code>slippery-chicken</code> object is made, so that
          the <code>make-slippery-chicken</code> function knows how to choose
          the pitches for the chords. Such a function could be defined as
          follows:</p>

        <pre class="source">
(defun piano-subset-fun (curve-num index pitch-list pitch-seq instrument set) 
  (declare (ignore curve-num index pitch-list pitch-seq instrument))
  (let* ((ss (when (subsets set) (get-data 'piano-chord (subsets set) nil)))
    (when ss 
      (make-chord (data ss)))))</pre>

        <p>This function ignores all of the required note-getting arguments
          except for <code>set</code>. It then declares the
          variable <code>ss</code> and says that its value will be determined
          by getting the data associated with the ID <code>piano-chord</code>
          in the <code>subsets</code> slot of the current set
          object. The <code>nil</code> is for the optional argument of
          the <code>get-data</code> method and indicates that no warning will
          be printed if there is no subset named <code>piano-chord</code>. The
          function then checks to see if
          <code>ss</code> now has a value, and if so, it uses the data
          contained in <code>ss</code> (i.e., the list of pitches from
          the <code>piano-chord</code> subset) to make a chord.</p>

        <p class="nb">NB: As a result of accessing <code>set</code> rather than
          <code>pitch-list</code>, no values assigned to
          <code>set-limits-high</code> or <code>set-limits-low</code> will be
          taken into account. See the section
          on <a href="./pitches.html#set-limits">set-limits-high and -low</a>
          for more on that feature. The <code>set-limits</code> could be taken
          into account here by first determining
          the <a href="../robodoc/pitch_lsp.html#pitch2fpitch2dintersection">
          <code>pitch-intersection</code></a> of the subset and the
          pitch-list.</p>

        <p>Once the function is defined, it must be assigned to the instrument
          that is to use it. That is done here using the <code>set-slot</code>
          method and assigning it to the <code>piano</code> instrument of
          the <code>+slippery-chicken-standard-instrument-palette+</code>:</p>

        <pre class="source">
(set-slot 'chord-function 'piano-subset-fun 'piano 
          +slippery-chicken-standard-instrument-palette+)</pre>

        <p>Now whenever <em>slippery chicken</em> encounters a chord indication
          for the <code>piano</code> instrument, it will always make the chord
          from the pitches in the <code>subset</code> of that set with the
          ID <code>piano-chord</code>.</p>

        <pre class="source">
(let* ((ss-chords-piece-1
       (make-slippery-chicken
        '+ss-chords-piece-1+
        :title "ss chords piece 1"
        :instrument-palette +slippery-chicken-standard-instrument-palette+
        :ensemble '(((pno (piano :midi-channel 1))))
        :tempo-map '((1 (q 60)))
        :set-palette '((1 ((f3 g3 a3 bf3 c4 d4 e4 f4 g4 a4 b4 c5 d5 e5 f5 g5)
                           :subsets ((piano-chord (c4 e4 g4))))))
        :set-map '((1 (1 1 1 1 1 1)))
        :rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                                :pitch-seq-palette ((8 (7) 8 7 (8) 7 8 7)))))
        :rthm-seq-map '((1 ((pno (1 1 1 1 1 1))))))))
  (write-lp-data-for-all ss-chords-piece-1 :base-path "/tmp/"))</pre>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-ss-fun-1.png"
                       alt="chords-ss-fun-1.png" width="770"/></td></td>
        </table>
        
        <p>However, the above code requires that there is a subset
          named <code>piano-chord</code> in <em>every</em> set from which
          chords are made for the <code>piano</code>. If
          <em>slippery chicken</em> attempts to make a chord from
          the <code>piano-chord</code> subset and that subset is not present in
          the current set, it will exit with an error. A
          second function could be used as a safeguard against this:</p>

        <pre class="source">
(defun piano-chord-master (curve-num index pitch-list pitch-seq instrument set)
  (let* ((xss (piano-subset-fun curve-num index pitch-list pitch-seq instrument
                        set)))
    (if xss
        xss
        (chord-fun2 curve-num index pitch-list pitch-seq instrument set))))</pre>

        <p>This function declares the variable <code>xss</code> to be the
          result of the <code>piano-subset-fun</code> function. If the current
          set has a subset named <code>piano-chord</code>, the result of
          the <code>piano-subset-fun</code> will be a chord; if not, the result
          will be <code>NIL</code>. If the result is a chord,
          the <code>piano-chord-master</code> uses that chord. If the result
          is <code>NIL</code>, the predefined <code>chord-fun2</code> function
          will be used instead.</p>

        <p>This is now the chord-function that the <code>piano</code>
          instrument must use, and must be assigned correspondingly:</p>

        <pre class="source">
(set-slot 'chord-function 'piano-chord-master 'piano 
          +slippery-chicken-standard-instrument-palette+)</pre>

        <p>Now whenever <em>slippery chicken</em> encounters a chord indication
          for the <code>piano</code> instrument, it will first try to make the
          chord from the pitches in the <code>subset</code> of that set with
          the ID <code>piano-chord</code>. If no such subset exists, it will
          make a chord using
          <code>chord-fun2</code>:</p>

        <pre class="source">
(let* ((ss-chords-piece-2
       (make-slippery-chicken
        '+ss-chords-piece-2+
        :title "ss chords piece 2"
        :instrument-palette +slippery-chicken-standard-instrument-palette+
        :ensemble '(((pno (piano :midi-channel 1))))
        :tempo-map '((1 (q 60)))
        :set-palette '((1 ((f3 g3 a3 bf3 c4 d4 e4 f4 g4 a4 b4 c5 d5 e5 f5 g5)
                           :subsets ((piano-chord (c4 e4 g4)))))
                       (2 ((fs3 gs3 as3 b3 cs4 ds4 e4 fs4 gs4 as4 b4 cs5 ds5 e5
                                fs5 gs5))))
        :set-map '((1 (1 2 1 2 1 2)))
        :rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                                :pitch-seq-palette ((8 (7) 8 7 (8) 7 8 7)))))
        :rthm-seq-map '((1 ((pno (1 1 1 1 1 1))))))))
  (write-lp-data-for-all ss-chords-piece-2 :base-path "/tmp/"))</pre>

        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-ss-fun-2.png"
                       alt="chords-ss-fun-2.png" width="800"/></td></td>
        </table>

        <p class="close"><a href="#" id="ss-fun-1-div-hide" class="hideLink"
              onclick="showHide('ss-fun-1-div');return
                       false;">close</a></p>
      </div>

      <h5 id="ss-fun-2"><a href="#ss-fun-2" id="ss-fun-2-div-show"
                           onclick="showHide('ss-fun-2-div');return
                           false;">+</a> 
        Example 2&mdash;Cycling through many subsets of the same set</h5>
      <div id="ss-fun-2-div" class="more">
        <p>The user may also want to have several chords available to an
          instrument when a specific set is used. This could be done using
          nested subsets (see the page
          on <a href="./pitches.html#adding-subsets">pitches</a> for more
          detail) and getting chords from the subset based on specific or
          random IDs.</p>

        <p>In addition to getting items from a set randomly or by using
          specific IDs, <em>slippery chicken</em> also has a
          built-in <em>cycling</em> feature for many of its classes. The
          software will remember the last item used for some lists, allowing
          the user to always get the <em>next</em> item from that list every
          time the list is accessed. That approach is employed in this second
          example.</p>

        <p>Using this feature makes the corresponding chord selection function
          much sleeker: </p>

        <pre class="source">
(defun piano-ss-fun2 (curve-num index pitch-list pitch-seq instrument set) 
 (declare (ignore curve-num index pitch-list pitch-seq instrument))
 (make-chord (data (get-next (get-data-data 'piano-chords (subsets set))))))</pre>

        <p>As with the first example, this function also only makes use of
          the <code>set</code> argument (and, like the first example, will also
          overlook any values assigned to <code>set-limits-high</code>
          and <code>-low</code>). It gets the data of the data associated with
          the id <code>piano-chords</code> in the <code>subsets</code> slot of
          the current set. This data is an object containing pitches. Each time
          the function is employed, it gets the <em>next</em> item in
          the <code>piano-chords</code> subset. It then makes a chord from the
          data (pitches) of that item.</p>

        <p>However, the <code>get-next</code> method will only work if it is
          used with one of the classes that allow cycling, and will cause
          <em>slippery chicken</em> to exit with an error otherwise. A nested
          subset would be the right kind of list, but if not all of
          the sets in the piece have a nested subset, an
          additional safeguard must be programmed to ensure that
          the <code>piano-ss-fun2</code> function is only used when the
          current set contains one. This safeguard can be similar
          to the safeguard from the first example, in that it runs a test, and
          if the test fails, it uses one of the predefined chord functions
          instead. </p>

        <pre class="source">
(defun piano-mc-2 (curve-num index pitch-list pitch-seq instrument set)
  (let* ((ss (when (subsets set) (get-data 'piano-chords (subsets set) nil)))
         (sss (when ss (data ss))))
    (if (is-ral sss)
        (piano-ss-fun2 curve-num index pitch-list pitch-seq instrument set)
        (piano-chord-fun curve-num index pitch-list pitch-seq instrument set))))</pre>

        <p>This function first declares the variable <code>ss</code> and
          assigns to it the data associated with the <code>piano-chords</code>
          ID in the <code>subsets</code> slot of the current set. If there is
          no subset with that ID, <code>ss</code> will automatically be given
          the value <code>NIL</code>. If there is such a subset, the
          variable <code>sss</code> is assigned to the data of that subset,
          which may be a list of pitches or a nested subset. The function then
          uses the <code>is-ral</code> function to test whether that data is a
          nested subset (a <em>recursive association list</em>,
          or <code>ral</code>). If it is a <code>recursive-assoc-list</code>,
          the function uses the <code>piano-ss-fun2</code> to get the next list
          of pitches from that <code>ral</code> and make the chord, otherwise
          it uses the predefined <code>piano-chord-fun</code>.  </p>

        <p>This function is assigned to the <code>chord-function</code> slot of
          the <code>piano</code> instrument the <code>instrument-palette</code>
          being used in the piece: </p>

        <pre class="source">
(set-slot 'chord-function 'piano-mc-2 'piano 
          +slippery-chicken-standard-instrument-palette+)</pre>

        <p>Now whenever <em>slippery chicken</em> encounters a chord indication
          for the <code>piano</code>, it will first try to get the next nested
          <code>subset</code> from the <code>subset</code> of the
          current set with the ID <code>piano-chords</code> and
          make a chord from those pitches. If no such subset exists, it will
          make a chord using <code>piano-chord-fun</code> instead:</p>

        <pre class="source">
(let* ((subset-piece-3
       (make-slippery-chicken
        '+subset-piece-3+
        :title "subset piece 3"
        :instrument-palette +slippery-chicken-standard-instrument-palette+
        :ensemble '(((pno (piano :midi-channel 1))))
        :tempo-map '((1 (q 60)))
        :set-palette '((1 ((f3 g3 a3 bf3 c4 d4 e4 f4 g4 a4 b4 c5 d5 e5 f5 g5)
                           :subsets ((piano-chords ((pno1 (c4 e4 g4))
                                                    (pno2 (d4 f4 a4))
                                                    (pno3 (e4 g4 b4)))))))
                       (2 ((fs3 gs3 as3 b3 cs4 ds4 e4 fs4 gs4 as4 b4 cs5))))   
        :set-map '((1 (1 2 1 2 1 2)))
        :rthm-seq-palette '((1 ((((4 4) - e e e e - - e e e e -))
                                :pitch-seq-palette ((8 (7) 8 7 (8) 7 8 7)))))
        :rthm-seq-map '((1 ((pno (1 1 1 1 1 1))))))))
  (write-lp-data-for-all subset-piece-3 :base-path "/tmp/"))</pre>


        <table class="image">
          <!-- for 150ppi LP png fragment examples scale by .75 -->
          <tr><td><img class="fragment" src="./resources/chords-ss-fun-3.png"
                       alt="chords-ss-fun-3.png" width="800"/></td></td>
        </table>

        <p class="close"><a href="#" id="ss-fun-2-div-hide" class="hideLink"
              onclick="showHide('ss-fun-2-div');return false;">close</a></p>
      </div>
      
      <!-- **************************************************************** --> 
      <!-- This spacer <br> is necessary as a buffer between the content and
           the footer. It cannot be added as padding to #push, since #push has
           to be the same size as #footer in order for the dynamic placement to
           work properly --> 
      <br /><br />
      <div id="push"></div>
    </div>
    <script type="text/javascript">footer();</script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
