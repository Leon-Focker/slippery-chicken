<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>slippery chicken documentation - "nouveau reich" &emdash;
      User-defined algorithms to generate and manipulate slippery-chicken
      data</title>  
    <!-- change the following two file paths to be ../ if in a subdirectory -->
    <link href="../sc-stylesheet.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="../head-foot.js"></script>
    <script language="javascript" type="text/javascript"
            src="../show-hide.js"></script>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>
  
  <body onload="showHide(window.location.hash.substring(1)+'-div')" >
    <div id="content">
      <!-- files in the doc directory will call header with argument "./" but
           those in subdirectories will need "../" -->
      <script type="text/javascript">header("../");</script>
      <noscript>Your browser does not support JavaScript!</noscript>
      <!-- **************************************************************** -->
      
      <h2>"Nouveau Reich" &mdash; User-defined algorithms to generate and
        manipulate slippery-chicken data</h2>   
      
      <h3 id="files"><a href="#files" id="files-div-show"
                        onclick="showHide('files-div');return false;">+</a>
        Associated files</h3>
      <div id="files-div" class="more">
        <ul>
          <li><a href="../examples/nouveau-reich.lsp">The
              slippery-chicken file from this guide</a></li>
          <li><a href="../media/nouveau-reich.mid">The MIDI output
              generated by this file</a></li>
          <li><a href="../media/_nouveau-reich-score.pdf">The PDF score
              produced with this file's LilyPond output </a></li>
          <li><a href="../media/nouveau-reich.eps">The CMN EPS output
              generated by this file</a></li>
          <li><a href="../media/nouveau-reich_mix.mp3">An MP3 of the
              piece using instrument samples</a></li>
        </ul>
        <p class="close"><a href="#" id="files-div-hide" class="hideLink"
                            onclick="showHide('files-div');return
                            false;">close</a></p> 
      </div>

      <p>This demo piece, <em>Nouveau Reich</em>, and its accompanying
        tutorial, will explore the use of user-defined algorithms for the
        generation of <em>slippery chicken</em> data. The code for this piece
        includes three functions which create lists that are then used as the
        values for keyword arguments to the <code>make-slippery-chicken</code>
        function.</p>

      <p>The resulting composition is an 18-minute work in the style of Steve
        Reich, with the content being an amalgamation of the chords from
        his <em>Music for 18 Musicians</em> and the melodic contours and
        phasing techniques of his <em>Piano Phase</em>, using <em>slippery
        chicken</em> to implement variations on his principle of <em>gradual
        process</em> in 75 lines of code.</p>

      <h3 id="code"><a href="#code" id="code-div-show"
                       onclick="showHide('code-div');return false;">+</a>
        The code</h3>
      <div id="code-div" class="more">
        <p>The code is first presented on its own here, then explained point by
          point below.</p>
        
        <p class="nb">NB: It is strongly recommended that the user not copy and
          paste code from the web browser into the Lisp listener, as this can
          occasionally lead to errors. The code below can be downloaded in
          complete form under the 
          <a href="#files" onclick="jumpShow('files-div')">Associated files</a>
          section above.</p>
        
        <pre class="source">
(defun move-first-to-end (list)
  (let (i)
    (setf i (pop list))
    (setf list (append list (list i)))))

(defun collect-n-rotations (num-rotations list-to-rotate)
  (loop repeat num-rotations
     collect list-to-rotate
     do (setf list-to-rotate (move-first-to-end list-to-rotate))))

(defun auto-curve-from-indices-and-items (indices items)
  (when (or (&lt;= (apply #'min indices) 0)
            (&gt; (apply #'max indices) (length items)))
    (error "all indices must be &gt;0 and &lt;= length of items"))
  (loop for pos in indices
     for x from 1
     collect x
     collect (nth (1- pos) items)))
  
(let* ((num-bars 646)
       (set-pal '((1 ((fs2 b2 d4 a4 d5 e5 a5 d6)))
                  (2 ((b2 fs3 d4 e4 a4 d5 e5 a5 d6)))
                  (3 ((cs3 fs3 e4 a4 e5 a5 e6)))
                  (4 ((fs2 cs3 e4 a4 b4 e5 a5 b5 e6)))
                  (5 ((d2 a2 e4 fs4 gs4 b4 e5 b5)))
                  (6 ((a2 e3 e4 fs4 gs4 b4 cs5 e5 b5)))
                  (7 ((cs3 fs3 fs4 gs4 a4 cs5 a5 cs6)))
                  (8 ((fs2 cs3 fs4 gs4 a4 b4 cs5 fs5)))
                  (9 ((e2 a2 cs4 fs4 gs4 a4 b4 e5 gs5 b5 e6)))
                  (10 ((d2 a2 fs4 gs4 a4 e5 a5 e6)))
                  (11 ((a2 d2 e4 fs4 a4 e5 a5)))))
       (fib-trans-ids (fibonacci-transitions 
                       num-bars
                       (loop for i from 1 to (length set-pal) collect i)))
       (set-limits-lists 
        (loop for pchs in '(((pno-one (a4 a4 e4 b4 fs4 gs4 gs4 gs4 b4 gs4
                                          e4)))
                            ((pno-two (d5 a4 e5 b4 gs4 gs4 a4 a4 gs4 a4
                                          a4))))  
           collect (loop for inst in pchs
                      collect (list (first inst)
                                    (auto-curve-from-indices-and-items 
                                     fib-trans-ids (second inst))))))
       (basic-bar '(((6 8) - s s s s s s - - s s s s s s -)))
       (ps-orig '(1 2 3 4 5 2 1 4 3 2 5 4))
       (ps-list (fibonacci-transitions num-bars 
                                       (collect-n-rotations 13 ps-orig)))
       (rsp (loop for rs from 1 to 2
               for psp in (list (list ps-orig) ps-list)
               collect (list rs (list basic-bar :pitch-seq-palette psp)))) 
       (rsm `((1 ,(loop for p in '(pno-one pno-two)
                     for rs from 1
                     collect (list p (loop repeat num-bars collect rs)))))) 
       (nouveau-reich
        (make-slippery-chicken
         '+nouveau-reich+
         :title "Nouveau Reich"
         :ensemble '(((pno-one (piano :midi-channel 1))
                      (pno-two (piano :midi-channel 2))))
         :staff-groupings '(1 1)
         :tempo-map '((1 (q. 72)))
         :set-palette set-pal
         :set-limits-low (first set-limits-lists)
         :set-limits-high (second set-limits-lists)
         :avoid-used-notes nil
         :avoid-melodic-octaves nil
         :set-map `((1 ,fib-trans-ids))
         :rthm-seq-palette rsp
         :rthm-seq-map rsm)))  
  (loop for p in '(pno-one pno-two)
     for n in '(("piano one" "pno i") ("piano two" "pno ii"))
     with e = (ensemble nouveau-reich)
     do 
       (setf (staff-name (get-data-data p e)) (first n))
       (setf (staff-short-name (get-data-data p e)) (second n)))
  (midi-play nouveau-reich :midi-file "/tmp/nouveau-reich.mid")
  (cmn-display nouveau-reich :file "/tmp/nouveau-reich")
  (write-lp-data-for-all nouveau-reich))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; EOF nouveau-reich.lsp</pre>
      
        <p class="close"><a href="#code" id="code-div-hide" class="hideLink"
                            onclick="showHide('code-div');return
                            false;">close</a></p>
      </div>

      <h3 id="explained">The code explained</h3>

 
      <h4 id="functions">The user-defined functions</code>
      <h5>move-first-to-end</h5>
      <p>The first of the four functions defined for this piece
        is <code>move-first-to-end</code>. This little function "pops" the
        first item off the list that it is given and appends it again to the
        end of that list. It is designed for use in the next
        function, <code>collect-n-rotations</code>.  </p>

      <pre class="source">
(defun move-first-to-end (list)
    (let (i)
      (setf i (pop list))
      (setf list (append list (list i)))))

(move-first-to-end '(1 2 3 4 5))

=> (2 3 4 5 1)</pre>

      <h5>collect-n-rotations</h5>
      <p>The second function defined here collects a list of the new lists
        created from consecutive calls to <code>move-first-to-end</code>. The
        user specifies an original list and the number of times that list is to
        be rotated. This function is designed for automatic generation
        of <code>pitch-seq</code> curves that will reflect Reich's technique of
        phasing.</p>
      
      <pre class="source">
(defun collect-n-rotations (num-rotations list-to-rotate)
    (loop repeat num-rotations
       collect list-to-rotate
       do (setf list-to-rotate (move-first-to-end list-to-rotate))))

(collect-n-rotations 11 '(1 2 3 4 5))

=>
((1 2 3 4 5) (2 3 4 5 1) (3 4 5 1 2) (4 5 1 2 3) (5 1 2 3 4) (1 2 3 4 5)
 (2 3 4 5 1) (3 4 5 1 2) (4 5 1 2 3) (5 1 2 3 4) (1 2 3 4 5))</pre>

      <h5>auto-curve-from-indices-and-items</h5>
      <p>The third user-defined function creates a list of break-point pairs
         with <tt>x</tt> values that increment by 1. It selects its <tt>y</tt>
         values from a list of specified items based on the pattern specified
         in a list of 1-based indices (integers) into that list. The indices
         must therefore all be between 1 and the length of the list of items,
         but the list of indices can be of any length, with its indices
         occurring in any order.</p>

      <p>This function is designed for the automatic generation of envelopes
        for the <code>set-limits-high</code> and <code>set-limits-low</code>
        arguments of the <code>make-slippery-chicken</code> function. It will
        ensure that limits are specified for each sequence in the piece, in
        order to avoid the interpolation of pitches that otherwise occurs when
        there are fewer break-point pairs than sequences.</p>
      
      <pre class="source">
(defun auto-curve-from-indices-and-items (indices items)
    (when (or (&lt;= (apply #'min indices) 0)
              (&gt; (apply #'max indices) (length items)))
      (error "all indices must be &gt;0 and &lt;= length of items"))
    (loop for pos in indices
       for x from 1
       collect x
       collect (nth (1- pos) items)))

(auto-curve-from-indices-and-items '(1 4 2 3 1 5 5 1 3 2 2 4) '(a b c d e))

=> (1 A 2 D 3 B 4 C 5 A 6 E 7 E 8 A 9 C 10 B 11 B 12 D)</pre>

      <h4 id="variables">Predefining variables with values for
        make-slippery-chicken</h4> 
      <h5>num-bars</h5>
      <p>The first variable declared, <code>num-bars</code>, actually
        determines the number of <em>sequences</em> that will be make up the
        piece. However, since the only <code>rthm-seq</code> that will be
        defined is exactly one bar long, the number of sequences is identical
        to the number of bars. This variable will be used either directly or
        indirectly to generate the <code>set-limits-</code> values, as well as
        the <code>rthm-seq-map</code> and <code>set-map</code>.</p>

      <pre class="source">
  (let* ((num-bars 646)</pre>

      <h5>set-pal</h5>
      <p>The next variable, <code>set-pal</code>, simply contains the list that
        will become the <code>set-palette</code> of
        the <code>slippery-chicken</code> object to be made. It is declared
        here, outside of the scope of that function, since the contents of
        the <code>fib-trans-ids</code> variable are dependent on the length of
        the <code>set-palette</code> for their generation.</p>

      <p>The chords used in this set palette are the 11 chords used in Steve
        Reich's <em>Music for 18 Musicians</em>.</p>

      <pre class="source">
         (set-pal '((1 ((fs2 b2 d4 a4 d5 e5 a5 d6)))
                    (2 ((b2 fs3 d4 e4 a4 d5 e5 a5 d6)))
                    (3 ((cs3 fs3 e4 a4 e5 a5 e6)))
                    (4 ((fs2 cs3 e4 a4 b4 e5 a5 b5 e6)))
                    (5 ((d2 a2 e4 fs4 gs4 b4 e5 b5)))
                    (6 ((a2 e3 e4 fs4 gs4 b4 cs5 e5 b5)))
                    (7 ((cs3 fs3 fs4 gs4 a4 cs5 a5 cs6)))
                    (8 ((fs2 cs3 fs4 gs4 a4 b4 cs5 fs5)))
                    (9 ((e2 a2 cs4 fs4 gs4 a4 b4 e5 gs5 b5 e6)))
                    (10 ((d2 a2 fs4 gs4 a4 e5 a5 e6)))
                    (11 ((a2 d2 e4 fs4 a4 e5 a5)))))</pre>

      <h5>fib-trans-ids</h5>
      <p>The <code>fib-trans-ids</code> variable uses
          the <code>fibonacci-transitions</code> function to generate a list
          that is <em>num-bars</em> long from consecutive numbers starting
          with <code>1</code> and ending with the length of
          the <code>set-pal</code> variable. The first purpose of this variable
          is the automatic generation of a series of set IDs for
          the <code>set-map</code> argument of
          the <code>make-slippery-chicken</code> function. It allows the user
          to change the number of sets in the <code>set-palette</code> and have
          the list of set IDs used for the <code>set-map</code> automatically
          adjusted accordingly.</p>

        <p>The <code>fib-trans-ids</code> variable will also be used to
          generate the lists for <code>set-limits-high</code>
          and <code>set-limits-low</code>, as is described in more detail
          below.</p>

        <pre class="source">
          (fib-trans-ids (fibonacci-transitions 
          num-bars
          (loop for i from 1 to (length set-pal) collect i)))</pre>

      <h5>set-limits-lists</h5>
      <h6 id="interpl">The set-limits- slots and interpolation</h6>
      <p>The <code>set-limits-high</code> and <code>set-limits-low</code> slots
        of the <code>slippery-chicken</code> object are designed to confine the
        pitches available to players in the ensemble (or to the ensemble as a
        whole) to subsets that gradually change over the course of the
        piece. They take lists of break-point pairs that are scaled to the
        number of sequences in the piece, and use them to change the pitch
        limits for the specified player on a sequence-by-sequence basis. If the
        list contains fewer break-point pairs than there are sequences in the
        piece, the pitch limits for the remaining sequences are determined
        through interpolation. Thus, if a piece has five sequences and the
        break-point pairs passed to <code>set-limits-high</code> for a player
        consist of <code>(0 f5 100 a5)</code>, the upper limit for that
        player's five sequences would
        be <code>f5</code>, <code>fs5</code>, <code>g5</code>, <code>gs5</code>,
        and <code>a5</code>. </p>

      <p>Since the <tt>x</tt> values passed to the <code>set-limits-</code>
        slots are scaled to the number of sequences in the piece, it can be
        helpful to use actual sequence numbers for these values rather than an
        arbitrary scale. If this approach were taken, the above list of
        break-point pairs could be written as <code>(1 f5 5 a5)</code>
        instead. </p>

      <p>If the user would like to avoid the interpolation of pitches between
        sequences, a break-point pair must be given for each individual
        sequence. If, for example, the user would prefer to have the set limits
        of the same five bars progress in whole-steps, skipping
        the <code>fs</code> and <code>gs</code>, this could be done by
        indicating <code>(1 f5 2 f5 3 g5 4 g5 5 a5)</code>.</p> 

      <p>The latter is the approach taken for <em>Nouveau Reich</em>, but since
        there are 646 sequences in the piece, the decision was made to generate
        these lists of break-point pairs automatically, using a loop to
        retrieve each sequential sequence number and pair it with an item from
        a predefined list of pitches.</p>

      <p class="nb">NB: In order to actually get the
        pitches <code>f5</code>, <code>g5</code> etc., these must also be
        present in the set being used for the current
        sequence. The <code>set-limits-</code> slots can consist of pitches
        that are not part of the set (and indeed most often will if the
        interpolating option is used.)</p>

      <h6>One list for both set-limits- slots</h6>
      <p>In order to avoid repeating code, a loop was defined for <em>Nouveau
        Reich</em> to generate the lists for both <code>set-limits-high</code>
        and <code>set-limits-low</code> in one step.
        The <code>make-slippery-chicken</code> function will later access these
        sublists by using <code>(first set-limits-lists)</code> for the former
        and and <code>(second set-limits-lists)</code> for the latter.  </p>

      <h6>Two five-pitch subsets for each set in the palette</h6>
      <p>Although it is not required that the pitches specified for the set
        limits are part of the current set, the pitches chosen here for
        <em>Nouveau Reich</em> are intentionally selected from each set in
        order to provide a subset of five pitches for each player in each
        section. This enables an exact mapping of the <code>pitch-seq</code>
        objects defined below, all consisting only of numbers <code>1</code>
        to <code>5</code>, to specific consecutive pitches within each subset.
        Each set in the piece is to be divided into the same two subsets each
        time it occurs.</p>

      <p>The five-pitch subsets are created by always giving
        the <code>pno-one</code> player the top five pitches of each set and
        the <code>pno-two</code> player the bottom five pitches of the same
        set, which may or may not overlap with those of
        the <code>pno-one</code>. This means that <code>set-limits-low</code>
        values are only required for <code>pno-one</code> (always specifying
        the fifth pitch from the top) and <code>set-limits-high</code> values
        are only required for <code>pno-two</code> (always specifying the fifth
        pitch from the bottom).</p>

      <p class="nb">NB: The exact mapping of pitches to <code>pitch-seqs</code>
        also requires use of the <code>:avoid-used-notes</code>
        and <code>:avoid-melodic-octaves</code> keywords of
        the <code>make-slippery-chicken</code> function, as described in more
        detail below.</p>

      <h6>Outer loop pairs players with pitches and determines form</h6>
      <p>The outer loop in the <code>set-limits-lists</code> therefore
        specifies lists of 11 pitches for each player, corresponding to sets 1
        to 11. These lists are each paired with the appropriate player
        ID. Additional parentheses are added in order to ensure that the form
        is complete and can be passed directly to the <code>:set-limits-</code>
        keywords of the <code>make-slippery-chicken</code> function.</p>

      <pre class="source">
         (set-limits-lists 
          (loop for pchs in '(((pno-one (a4 a4 e4 b4 fs4 gs4 gs4 gs4 b4 gs4
                                            e4)))
                              ((pno-two (d5 a4 e5 b4 gs4 gs4 a4 a4 gs4 a4
                                            a4)))) </pre>

      <h6>Implementing the auto-curve-from-indices-and-items function</h6>
      <p>The inner loop uses the <code>auto-curve-from-indices-and-items</code>
        function defined above to generate a list of break-point pairs whose
        <tt>x</tt> values start at <code>1</code> and increment
        by <code>1</code> for the number of items in the list of indices. For
        its list of indices, it uses the same list generated for the
        <code>fib-trans-ids</code> variable, thereby ensuring that there are
        the same number of pitch limits as there are sets in the set map, and
        that the same pitch limits are always paired with the same sets from
        the <code>set-palette</code>.</p>

      <pre class="source">
             collect (loop for inst in pchs
                        collect (list (first inst)
                                      (auto-curve-from-indices-and-items 
                                       fib-trans-ids (second inst))))))</pre>

      <h5>basic-bar, ps-orig, ps-list, and rsp</h5>
      <p>The next four variables are used to algorithmically construct
        the <code>rthm-seq-palette</code>, using the
        function <code>collect-n-rotations</code> defined above.</p>

      <h6>basic-bar</h6> 
      <p>Leaning on the <em>phasing</em> technique found in Steve
        Reich's <em>Piano Phase</em>, the only rhythmic material for this piece
        will consist of 12 sixteenth notes in a 6/8 bar. This bar is defined
        once as <code>basic-bar</code>. </p>

      <pre class="source">
         (basic-bar '(((6 8) - s s s s s s - - s s s s s s -)))</pre>

      <h6>Reich's principle of phasing</h6>
      <p>Reich's principal of <em>phasing</em> consists of having two players
        play the same rhythmic pattern and/or melodic contour, initially in
        unison, and gradually changing the second player's part by shifting the
        pattern in only that player's part by one unit at a time. The first
        unit in the pattern is taken off the front of the pattern and moved to
        the end, thus taking it more and more "out of phase" with each
        rotation. One of the fascinating by-products of the <em>phasing</em>
        technique are what Reich calls <em>resulting patterns</em>: new melodic
        patterns and sensations of changing meter that emerge at each
        shift.</p>

      <h6>Non-phasing and phasing pitch-seqs</h6>
      <p>Since the rhythmic pattern in this piece consists of consecutive
        sixteenths, only a shift of the melodic contour will produce an audible
        phasing effect. The code for this piece therefore defines an original
        melodic contour, as <code>ps-orig</code>, and then a collection of
        gradually shifting permutations of that contour using
        the <code>collect-n-rotations</code> function defined above in
        combination with <code>fibonacci-transitions</code>. </p>

      <p>The <code>collect-n-rotations</code> function is first used to collect
        a list of 13 rotations of the original <code>pitch-seq</code>, meaning
        the players will start and end with "unison" melodic contours, and the
        second player will gradually pass through all possible rotations of the
        original <code>pitch-seq</code> in the course of the piece. This list
        of 13 rotations is then passed to
        the <code>fibonacci-transitions</code> function with
        the <code>num-bars</code> argument to generate a list
        of <code>pitch-seq</code> curves that has one <code>pitch-seq</code>
        for each sequence.</p>

      <pre class="source">
         (ps-orig '(1 2 3 4 5 2 1 4 3 2 5 4))
         (ps-list (fibonacci-transitions num-bars 
                                         (collect-n-rotations 13 ps-orig)))</pre>

      <h6>Generating the rthm-seq-palette</h6>
      <p>A short loop is then used to construct a <code>rthm-seq-palette</code>
        consisting of only two <code>rthm-seqs</code>. At each pass through the
        loop, a <code>rthm-seq</code>, with ID <code>1</code>
        or <code>2</code>, is created by combining the <code>basic-bar</code>
        with a different <code>pitch-seq-palette</code>.
        The <code>ps-orig</code> is used as the sole <code>pitch-seq</code> in
        the <code>pitch-seq-palette</code> for the first <code>rthm-seq</code>,
        and the <code>ps-list</code> is used for the second. (Also see the page
        on using <a href="./pitches.html#multi-ps">multiple curves in the same
        pitch-seq-palette</a>).</p>

      <pre class="source">
         (rsp (loop for rs from 1 to 2
                 for psp in (list (list ps-orig) ps-list)
                 collect (list rs (list basic-bar :pitch-seq-palette psp)))) </pre>

      <h5>Generating the rthm-seq-map</h5>
      <p>The final bit of content to be generated for
        the <code>make-slippery-chicken</code> function is
        the <code>rthm-seq-map</code>. This too is done using a small loop,
        this time collecting a list of multiple repetitions of
        either <code>1</code>, <code>2</code>, or <code>nil</code> for the
        players <code>pno-one</code>, <code>pno-two</code>,
        and <code>pno-two-lh</code>. </p>

      <p>This variable is defined using Lisp's <em>backquote</em>
        and <em>comma</em> reader macros, allowing the code to be formulated
        more concisely. More on these macros can be found in the entry
        for <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_df.htm">backquote</a>
        at
        the <a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">Common
        Lisp HyperSpec</a>. </p>

      <pre class="source">
         (rsm `((1 ,(loop for p in '(pno-one pno-two pno-two-lh)
                       for rs in '(1 2 nil)
                       collect (list p (loop repeat num-bars collect rs)))))) </pre>

      <h5 id="msc-var">The call to make-slippery-chicken within a variable</h5>
      <p>The last variable to be declared within the <code>let*</code>
        expression is <code>nouveau-reich</code>. This variable will contain
        the entire <code>slippery-chicken</code> object generated by calling
        the <code>make-slippery-chicken</code> function, using the other
        variables defined above as the values for its arguments. Compared to
        the code for <em>Primary Disposition</em> and <em>Second Law</em>, this
        call to <code>make-slippery-chicken</code> looks very sleek. </p>

      <p>This piece introduces two new keyword arguments of
        the <code>make-slippery-chicken</code> function,
        namely <code>avoid-used-notes</code>
        and <code>avoid-melodic-octaves</code>, which are both required for the
        exact mapping of the <code>pitch-seqs</code> of <code>ps-orig</code>
        and <code>ps-list</code> to the 5-pitch subsets defined above. </p>

      <pre class="source">
         (nouveau-reich
          (make-slippery-chicken
           '+nouveau-reich+
           :ensemble '(((pno-one (piano :midi-channel 1))
                        (pno-two (piano :midi-channel 2))
                        (pno-two-lh (piano-lh :midi-channel 2))))
           :staff-groupings '(1 2)
           :tempo-map '((1 (q. 72)))
           :set-palette set-pal
           :set-limits-low (first set-limits-lists)
           :set-limits-high (second set-limits-lists)
           :avoid-used-notes nil
           :avoid-melodic-octaves nil
           :set-map `((1 ,fib-trans-ids))
           :rthm-seq-palette rsp
           :rthm-seq-map rsm)))  </pre> 

      <h6 id="used">avoid-used-notes</h6>
      <p>By default, <em>slippery chicken's</em> automatic pitch-selection
        algorithm endeavors to prevent the same pitch from being assigned to
        more than one player in any given sequence. However, as some of the
        subsets created by the <code>set-limits-lists</code> loop overlap in
        their pitch content, this would result in some of those subsets having
        fewer than five pitches. In order to ensure that each of the subsets
        has five pitches, even if some of those subsets contain the same
        pitches for the same sequence, so that the <code>pitch-seq</code>
        numbers can be exactly mapped to those pitches,
        the <code>avoid-used-notes</code> keyword can be set
        to <code>NIL</code>. </p>
      
      <pre class="source">
           :avoid-used-notes nil</pre>

      <h6 id="octaves">avoid-melodic-octaves</h6>
      <p>Another default feature of <em>slippery chicken's</em> pitch-selection
        algorithm is the avoidance of melodic octaves. This feature will
        prevent two non-unison pitches of the same pitch-class from occurring
        in sequence in any player's part. This rule, too, will prevent the
        exact mapping of <code>pitch-seq</code> numbers to pitches of the
        five-pitch subsets. For this piece, therefore, this feature is also
        disabled by setting the <code>avoid-melodic-octaves</code> keyword of
        the <code>make-slippery-chicken</code> function
        to <code>NIL</code>. </p>

      <pre class="source">
         :avoid-melodic-octaves nil</pre>

      <h4 id="names">Changing staff names in an existing sc object</h4>
      <p>Since both players in the <em>Nouveau Reich</em> ensemble use the
        same <code>instrument</code> object of
        the <code>+slippery-chicken-standard-instrument-palette+</code>, they
        will, by default, each have the same full and abbreviated staff names
        in the score. This can be remedied by changing the value of
        the <code>staff-name</code> and <code>staff-short-name</code> slots of
        the corresponding <code>instrument</code> objects within
        the <code>ensemble</code> object stored in
        the <code>slippery-chicken</code> object's <code>ensemble</code>
        slot. The data in this <code>ensemble</code> object is copied from and
        separate to that of the <code>instrument-palette</code>, and can
        therefore be changed independently. This is done here using a loop
        after the <code>slippery-chicken</code> object has been made.</p>

      <pre class="source">
  (loop for p in '(pno-one pno-two)
     for n in '(("piano one" "pno i") ("piano two" "pno ii"))
     with e = (ensemble nouveau-reich)
     do 
       (setf (staff-name (get-data-data p e)) (first n))
       (setf (staff-short-name (get-data-data p e)) (second n)))</pre>

   <p class="nb">Since 28/5/14 Staff names can now also be set when
   initialising a slippery-chicken object, e.g.:

<pre class="source">
(make-slippery-chicken
 '+mini+
 :ensemble '(((vn1 (violin :midi-channel 1 :staff-names "violin I"))
              (vn2 (violin :midi-channel 2 :staff-names "violin II"))
              (vc (cello :midi-channel 3))))
 :set-palette '((1 ((gs3 as3 b3 cs4 ds4 e4 fs4 gs4 as4 b4 cs5))))
 :set-map '((1 (1 1 1 1 1)))
 :rthm-seq-palette '((1 ((((2 4) q (e) s (32) 32))
                         :pitch-seq-palette ((1 2 3)))))
 :rthm-seq-map '((1 ((vn1 (1 1 1 1 1))
                     (vn2 (1 1 1 1 1))
                     (vc (1 1 1 1 1))))))))</pre>

    <p class="nb">However, do see <a href="coreUsage.html#lp-ins-names">this
note</a> for information about Lilypond and instrument names.

<p>Note also that when a player doubles, it is possible to define names and
short names for all the instruments used. In this case the strings are simply
passed in a list, in the instrument order, as shown below: 
</p>
<pre class="source">
(let ((mini
       (make-slippery-chicken
        '+mini+
        :ensemble '(((solo ((marimba vibraphone) :midi-channel 1
                            :staff-names ("big wood" "big metal")
                            :staff-short-names ("bw" "bm")))))
        :instrument-change-map '((1 ((solo ((1 vibraphone) (3 marimba))))))
        :set-palette '((1 ((c4))))
        :set-map '((1 (1 1 1 1 1)))
        :rthm-seq-palette
        '((1 ((((4 4) (4 (1 1 1 1))))))
          (2 ((((4 4) (4 (1 1 1 (1 (1 1))))))))
          (3 ((((4 4) (4 (1 1 1 (2 (1 1))))))))
          (4 ((((4 4) (4 (1 1 (2 (1 1 1))))))))
          (5 ((((4 4) { 3 (te) { 3 (18) 36 } { 3 - 36 36 36 - } }
                (1 ((4 (1 (1) 1 1 1)) (5 (1 1 1 1))))
                (1 (1 (3 (1 1 1 1))))
                { 5 - fs x 5 - })))))
        :rthm-seq-map '((1 ((solo (1 2 3 4 5))))))))
  (lp-display mini))</pre>




      <h4>The output</h4>
      <p>With all this done, the output for <em>Nouveau Reich</em> can be
        easily generated in the same manner as for <em>Primary
        Disposition</em> and <em>Second Law</em>. As this piece has 646 bars
        and several internal loops for generating data that is processed for
        each of those bars, the generation time can be quite long. The result
        is a 28-page LilyPond score, a 41-page CMN score, and an 18-minute
        MIDI file.</p>


      <pre class="source">
  (midi-play nouveau-reich :midi-file "/tmp/nouveau-reich.mid")
  (cmn-display nouveau-reich :file "/tmp/nouveau-reich")
  (write-lp-data-for-all nouveau-reich))</pre>
    
    <!-- **************************************************************** --> 
    <!-- This spacer <br> is necessary as a buffer between the content and
         the footer. It cannot be added as padding to #push, since #push has to
         be the same size as #footer in order for the dynamic placement to work
         properly --> 
    <br /><br />
    <div id="push"></div>
    </div>
    <script type="text/javascript">footer();</script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
