<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>slippery chicken documentation - "second law" - intra-phrasal
      looping</title>
    <!-- change the following two file paths to be ../ if in a subdirectory -->
    <link href="../sc-stylesheet.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="../head-foot.js"></script>
    <script language="javascript" type="text/javascript"
            src="../show-hide.js"></script>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>
  
  <body onload="showHide(window.location.hash.substring(1)+'-div')" >
    <div id="content">
      <!-- files in the doc directory will call header with argument "./" but
           those in subdirectories will need "../" -->
      <script type="text/javascript">header("../");</script>
      <noscript>Your browser does not support JavaScript!</noscript>
      <!-- **************************************************************** -->
      
      <h2>"Second Law" &mdash; Intra-phrasal looping</h2>

      <h3 id="files"><a href="#files" id="files-div-show"
                        onclick="showHide('files-div');return
                                 false;">+</a> 
        Associated files</h3>
      <div id="files-div" class="more">
        <ul>
          <li><a href="../examples/second-law.lsp">The slippery-chicken file
              from this example</a></li>
          <li><a href="../media/second-law.mid">The MIDI output generated by
              this file</a></li>
          <li><a href="../media/_second-law-score.pdf">The PDF score produced
              with this file's LilyPond output </a></li>
          <li><a href="../media/second-law.eps">The CMN EPS output generated by
              this file</a></li>
          <li><a href="../media/second-law_mix.mp3">An MP3 of the piece using
              instrument samples</a></li>
        </ul>
        <p class="close"><a href="#" id="files-div-hide" class="hideLink"
              onclick="showHide('files-div');return false;">close</a></p>
	<br />
      </div>

      <p class="nb">NB: An exercise relating to the material covered
	in this tutorial can be found on
	the <a href="./exercises.html#looping">Exercises</a> page.</p>
      
      <p>This document assumes that you having familiarized yourself with the
        <a href="./coreUsage.html">core usage</a> of <em>slippery chicken</em>.
        It provides an introduction to generating some of the material
        for <em>slippery chicken</em> algorithmically, using
        the <code>chop</code> method and the <code>fibonacci-transitions</code>
        function to create <em>intra-phrasal looping</em>, in addition to
        integrating separate Lisp routines.</p>
    
    <p><em>Intra-phrasal looping</em> is a compositional process made possible
      by <em>slippery chicken</em> and is a technique that demonstrates the
      strengths of using <em>slippery chicken</em> as a compositional tool. It
      allows the user to produce an entire, motivically coherent and
      structurally sound composition from a small amount of source material and
      a few concisely defined processes, even automatically incorporating
      musical elements such as orchestration and larger-scale structure.</p>
    
    <h3 id="code"><a href="#code" id="code-div-show"
                     onclick="showHide('code-div');return
                     false;">+</a> 
      The code</h3>
    <div id="code-div" class="more">
      <p>The code is first presented on its own here, then explained point by
        point below.</p>

      <p class="nb">NB: It is strongly recommended that the user not copy and
        paste code from the web browser into the Lisp listener, as this can
        occasionally lead to errors. The code below can be downloaded in
        complete form under the <a href="#files"
        onclick="jumpShow('files-div')">Associated files</a> section above.</p>

      <pre class="source">
(let* ((sl-rsp-orig ; defining the source material
        (make-rsp
         'sl-rsp
         '((1 
            ;; A backslash (\) must be used as an escape character when
            ;; indicating a tie to the previous note using a + symbol before a
            ;; numerically represented rhythmic value (as opposed to a letter,
            ;; such as 's or 'e). (This is because Lisp will otherwise read
            ;; "+32" as "positive 32".)
            ((((4 4) - (e.) s - - \+32 32 32 32 (e) - 
               - 32 32 (s) 32 32 32 (32) - - (s) s s (s) - )
              (- (e..) 32 - +q q (q))
              (h. (q)))
             :pitch-seq-palette ((1 2 1 2 3 2 3 3 1 2 5 5 7 6)
                                 (2 1 2 1 2 3 2 2 4 3 2 2 1 2)
                                 (5 3 4 5 4 5 4 5 2 3 6 6 8 7))
             :marks (a 1 s 1 slur 3 5 a 6 slur 6 7 slur 8 10 a 11 s 11 12 
                       a 13))))))
       
       ;; fragmenting the source material
       (sl-rsp-chopped (chop sl-rsp-orig 
                             '((1 2) (1 1) (2 2)) ; chop points
                             'e)) ; chopping unit
       
       ;; setting the measure structure
       (num-seqs-list '(53 61 97 79 89 73)))
 
  ;; adjusting the instrument attributes
  (loop for i in 
         '((flute 13)
           (oboe 7)
           (b-flat-clarinet 9)
           (bassoon 7)
           (french-horn 5)
           (b-flat-trumpet 7)
           (tenor-trombone 5)
           (double-bass 5))
     do
       (set-slot 'largest-fast-leap 
                 (second i)
                 (first i)
                 +slippery-chicken-standard-instrument-palette+))
  

  ;; This function prints the results of the chop method in easy-to-read form 
  ;; (print-simple sl-rsp-chopped)

  ;; calling slippery-chicken
  (make-slippery-chicken
   '+second-law+
   :title "Second Law"
   :instrument-palette +slippery-chicken-standard-instrument-palette+
   :ensemble '(((fl (flute :midi-channel 1))
                (ob (oboe :midi-channel 2))
                (cl (b-flat-clarinet :midi-channel 3))
                (bn (bassoon :midi-channel 4))
                (hn (french-horn :midi-channel 5))
                (tp (b-flat-trumpet :midi-channel 6))
                (tb (tenor-trombone :midi-channel 7))
                (vno (violin :midi-channel 8))
                (vnt (violin :midi-channel 9))
                (va (viola :midi-channel 12))
                (vc (cello :midi-channel 13))
                (cb (double-bass :midi-channel 14))))

   ;; setting pitch ranges for the scope of this composition
   :set-limits-high '((cl (0 c6 100 c6))
                      (vc (0 a4 100 a4))
                      (cb (0 f3 100 f3)))
   :staff-groupings '(4 3 5)
   :tempo-map '((1 (q 69)))
   :set-palette '((1 ((c3 g3 cs4 e4 fs4 a4 bf4 c5 d5 f5 gf5 af5 ef6)))
                  (2 ((c3 fs3 cs4 e4 g4 a4 b4 c5 df5 f5 g5 af5 ef6)))
                  (3 ((d3 f3 cs4 e4 fs4 a4 b4 c5 d5 e5 fs5 af5 ef6)))
                  (4 ((d3 e3 cs4 ef4 fs4 a4 b4 c5 d5 e5 fs5 af5 d6)))
                  (5 ((d3 e3 g3 a3 c4 ef4 f4 af4 bf4 cs5 fs5 b5 df6)))
                  (6 ((c3 d3 gf3 af3 b3 e4 a4 df5 ef5 g5 bf5 df6)))
                  (7 ((b2 e3 fs3 as3 ef4 g4 a4 d5 f5 af5 c6 df6)))
                  (8 ((af2 b2 ef3 fs3 as3 cs4 e4 g4 a4 d5 f5 bf5 c6 e6 af6)))
                  (9 ((af2 b2 ef3 fs3 bf3 d4 f4 a4 cs5 e5 g5 c6 f5 af6)))
                  (10 ((af2 c3 ef3 fs3 bf4 d4 f4 a4 cs5 e5 g5 b5 fs6))))
   
   ;; using a Lisp routine to generate the set-map
   :set-map (loop for section in 
                 '((1 (1 2 3)) 
                   (2 (2 3 4 1))
                   (3 (1 3 5 6 7))
                   (4 (8 9))
                   (5 (5 6 7 9 3))
                   (6 (9 10)))
               collect
                 (list (first section)
                       (fibonacci-transitions 
                        (nth (1- (first section)) num-seqs-list)
                        (second section))))

   :rthm-seq-palette sl-rsp-chopped
   
   ;; using a Lisp routine to generate the rthm-seq-map
   :rthm-seq-map (loop for section in
                      '((((1 3) fl ob ))
                        (((3 4) fl ob cl))
                        (((5 6 7 8) fl ob cl)
                         ((11 12 13 14) bn tb vc cb))
                        (((9 10 11) hn tp))
                        (((15 16 25 26) fl ob vno vnt)
                         ((9 10 13 14) cl hn va)
                         ((3 1 16 3) tp tb)
                         ((12 13 10 11) bn vc cb))
                        (((1 3 4) fl ob cl bn hn tp tb vno vnt va vc cb)))
                    for section-num from 1
                    collect 
                      (list section-num
                            (loop for ins-group in section 
                               appending
                                 (loop with fts =
                                      (loop for ch in (first ins-group) 
                                         collect
                                           (list 1 ch))
                                    for ins in (rest ins-group) 
                                    collect
                                      (list ins
                                            (fibonacci-transitions
                                             (nth (1- section-num)
                                                  num-seqs-list) 
                                             fts))))))))

;; The re-bar method can be applied outside of the above "let*" scope, since
;; the slippery-chicken class produces a global variable from its first
;; argument
(re-bar +second-law+
        :min-time-sig '(4 4) 
        :auto-beam 'q)

;;; the output:
;;; midi
(midi-play +second-law+ :midi-file "/tmp/second-law.mid")

;; CMN output
(cmn-display +second-law+ :file "/tmp/second-law.eps" :size 12)

;; LP output
(write-lp-data-for-all +second-law+ :base-path "/tmp/")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; EOF</pre>

      <p class="close"><a href="#" id="code-div-hide" class="hideLink"
            onclick="showHide('code-div');return false;">close</a></p>
    </div>

    <h3>The code explained</h3>
    <p>The material for the <code>rthm-seq-palette</code>,
      the <code>rthm-seq-map</code>, and the <code>set-map</code> for this
      composition is generated algorithmically. Two of the options for
      algorithmically generating material are to place the generating code
      directly into the <code>slippery-chicken</code> object, as can be seen in
      the <code>set-map</code> and <code>rthm-seq-map</code> blocks, or to
      assign the generating code to variables, as has been done here at the top
      of the example. </p>

    <h4>Setting up the environment</h4>
    <p>As in the <a href="./coreUsage.html">core usage tutorial</a>, this
      example first sets the global parameters for <code>package</code>
      and <code>scale</code>: </p>

    <pre class="source">
(in-package :sc)

(in-scale :chromatic)</pre>

    <h4>Setting up the scope</h4>
    <h5 id="variables">Setting the variables</h5>
    <p>The variables in this example are declared using the <code>let</code>
      macro and enclosed in the same scope as the call to
      the <code>make-slippery-chicken</code> function below them, allowing the
      material assigned to these variables to be used in that
      function. (Another option would be to declare global variables for the
      material, but the <code>let</code> option is more concise.)</p>

    <p>Three variables are declared here. The first,
      <code>sl-rsp-orig</code>, stores the <code>rthm-seq-palette</code> that
      serves as the source material for this piece. The
      second, <code>sl-rsp-chopped</code>, stores the results of applying
      the <code>chop</code> method to the contents of
      the <code>sl-rsp-orig</code> variable. The <code>chop</code> method
      itself returns a <code>rthm-seq-palette</code> object, and can therefore
      be directly passed to the <code>:rthm-seq-palette</code> keyword argument
      within the subsequent call to the <code>make-slippery-chicken</code>
      function. This method will be described in more detail below. The third
      variable, <code>num-seqs-list</code>, is a list of numbers that will be
      the number of <code>rthm-seq</code> objects and sets
      in each of their respective maps within the
      <code>slippery-chicken</code> object, thereby determining the length of
      each section. </p>

    <h5 id="orig-rsp">The original rthm-seq-palette</h5>
    <p>The original palette is constructed in essentially the same way as in
      the <a href="./coreUsage.html">core usage</a> guide, with one new
      attribute, namely that this example defines more than one curve
      (<code>pitch-seq</code>) for the <code>pitch-seq-palette</code>.</p>

    <pre class="source">
             :pitch-seq-palette ((1 2 1 2 3 2 3 3 1 2 5 5 7 6)
                                 (2 1 2 1 2 3 2 2 4 3 2 2 1 2)
                                 (5 3 4 5 4 5 4 5 2 3 6 6 8 7))</pre>

    <p>See the page on using <a href="./pitches.html#multi-ps">multiple curves
        in the same :pitch-seq-palette</a> for more detail on this feature.</p>

    <h5 id="inst-atts">Adjusting instrument attributes for the scope of the
      piece</h5>
    <p>The last element before the creation of
      the <code>slippery-chicken</code> object is a short routine that adjusts
      the <code>largest-fast-leap</code> value of the <code>instrument</code>
      objects used in the composition.</p>
    
    <pre class="source">
  (loop for i in 
       '((flute 13)
         (oboe 7)
         (b-flat-clarinet 9)
         (bassoon 7)
         (french-horn 5)
         (b-flat-trumpet 7)
         (tenor-trombone 5)
         (double-bass 5))
     do
       (set-slot 'largest-fast-leap 
                 (second i)
                 (first i)
                 +slippery-chicken-standard-instrument-palette+))</pre>

    <p>This loop passes through a list of instrument names paired with numbers
      and sets the <code>largest-fast-leap</code> value of the
      corresponding <code>instrument</code> object in the global
      <code>+slippery-chicken-standard-instrument-palette+</code> (which is
      the <code>instrument-palette</code> used in this piece) to the given
      number. Note that the instrument names here are the IDs in the given
      <code>instrument-palette</code>, not the user-defined player IDs in
      the <code>ensemble</code> block.</p>

    <p>This routine limits the maximum linear interval between two consecutive
      32nd-notes for each of the instruments in the list to a relatively small
      span (mostly perfect fourths and fifths), ensuring that the resulting
      music is more easily playable.</p>

    <p>More information on the <code>largest-fast-leaps</code> and other slots
      of the <code>instrument</code> class can be found in the source
      documentation <a href="../robodoc/instrument_lsp.html#robo121">here</a>.
      Also see the page on <a href="./instruments.html">tailoring instrument
      definitions</a> for related information.</p>

    <h4>The call to make-slippery-chicken</h4>
    <p>Many of the components of the <code>make-slippery-chicken</code>
      function for this piece are the same as in
      the <a href="./coreUsage.html">core-usage</a> guide. Thus, the usage of
      the initial global variable, as well as
      the <code>title</code>, <code>instrument-palette</code>,
      <code>ensemble</code>,
      <code>staff-groupings</code>, and <code>tempo-map</code> blocks will
      not be discussed here.</p>

    <h5 id="tessitura">Setting tessitura for one piece</h5>
    <p>Although the <code>set-slot</code> method used above could be used here
      as well to set the upper limits for instrument ranges for the entirety of
      the given piece, this example uses the <code>:set-limits-high</code>
      keyword argument of the <code>make-slippery-chicken</code> function to
      cap the upper limits of the clarinet, cello, and bass for the duration of
      the piece:</p>

    <pre class="source">
   :set-limits-high '((cl (0 c6 100 c6))
                      (vc (0 a4 100 a4))
                      (cb (0 f3 100 f3)))</pre>
    
    <p>See the page on <a href="./pitches.html#set-limits">pitches</a> for more
      details on the usage of <code>:set-limits-high</code>
      and <code>:set-limits-low</code>.</p>
    
    <h5 id="set-planning">Well-considered set palettes</h5>
    <p>The <code>set-palette</code> for this example is constructed by hand
      and not algorithmically. Emphasis was placed on choosing pitches that are
      seldom more than a third apart, to allow for smoother lines in the
      instruments. </p>

    <pre class="source">
   :set-palette '((1 ((c3 g3 cs4 e4 fs4 a4 bf4 c5 d5 f5 gf5 af5 ef6)))
                  (2 ((c3 fs3 cs4 e4 g4 a4 b4 c5 df5 f5 g5 af5 ef6)))
                  (3 ((d3 f3 cs4 e4 fs4 a4 b4 c5 d5 e5 fs5 af5 ef6)))
                  (4 ((d3 e3 cs4 ef4 fs4 a4 b4 c5 d5 e5 fs5 af5 d6)))
                  (5 ((d3 e3 g3 a3 c4 ef4 f4 af4 bf4 cs5 fs5 b5 df6)))
                  (6 ((c3 d3 gf3 af3 b3 e4 a4 df5 ef5 g5 bf5 df6)))
                  (7 ((b2 e3 fs3 as3 ef4 g4 a4 d5 f5 af5 c6 df6)))
                  (8 ((af2 b2 ef3 fs3 as3 cs4 e4 g4 a4 d5 f5 bf5 c6 e6 af6)))
                  (9 ((af2 b2 ef3 fs3 bf3 d4 f4 a4 cs5 e5 g5 c6 f5 af6)))
                  (10 ((af2 c3 ef3 fs3 bf4 d4 f4 a4 cs5 e5 g5 b5 fs6))))</pre>

    <p>Another important attribute of this particular <code>set-palette</code>
      definition is that the IDs of each of the sets are consecutive
      integers. Although these IDs could be numbers or alphabetic symbols, the
      use of numbers facilitates the implementation of
      the <code>fibonacci-transitions</code> function below.</p>

    <p>See the page on <a href="./pitches.html#set-palettes">pitches</a> for
      more details on the usage of <code>set-palettes</code>.</p>

    <h4 id="fibonacci">An application of fibonacci-transitions</h4>
    <p>The <code>fibonacci-transitions</code> function is used several times in
      this composition (see the page
      <a href="./fibonacci.html#trans">Fibonacci Transitions</a> for a general
      introduction to the function). It occurs for the first time in the
      generation of the <code>set-map</code>, in conjunction with the
      variable <code>num-seqs-list</code>. </p>

    <pre class="source">
       (num-seqs-list '(53 61 97 79 89 73)))

   :set-map (loop for section in 
                 '((1 (1 2 3)) 
                   (2 (2 3 4 1))
                   (3 (1 3 5 6 7))
                   (4 (8 9))
                   (5 (5 6 7 9 3))
                   (6 (9 10)))
               collect
                 (list (first section)
                       (fibonacci-transitions 
                        (nth (1- (first section)) num-seqs-list)
                        (second section)))) </pre>


    <p>For each number-list pair in the <code>loop</code>,
      the <code>fibonacci-transitions</code> function is called and applied to
      the list of numbers of that pair (accessed by
      <code>(second section)</code>) according to the number of times
      stipulated by the corresponding <code>nth</code> element of
      the <code>num-seqs-list</code>. The result is then collected into a list
      with the corresponding section number (accessed by
      <code>(first section)</code>) and passed to the <code>set-map</code>
      keyword argument of the call to <code>slippery-chicken</code>. The loop
      eliminates the need for a series of individual calls
      to <code>fibonacci-transitions</code> that would look like: </p>

    <pre class="source">
      (fibonacci-transitions 53 '(1 2 3))
      (fibonacci-transitions 61 '(2 3 4 1))
      etc.</pre>

    <p>Its result, if typed in manually instead, would look like this:</p>

    <pre class="source">
((1
  (1 1 1 1 1 1 2 1 1 1 1 2 1 1 2 1 2 2 2 1 2 1 2 2 2 2 2 2 2 3 2 2 3 2 3 3
   3 2 3 2 3 3 3 2 3 3 3 3 3 3 3 3 3))
 (2
  (2 2 2 2 2 3 2 2 2 2 3 2 2 3 2 3 2 3 2 3 3 3 3 3 4 3 4 3 4 3 4 3 4 3 4 4
   4 4 4 1 4 1 4 1 4 1 4 1 4 1 1 1 4 1 1 1 1 1 1 1 1))
 (3
  (1 1 1 1 1 1 1 3 1 1 1 1 3 1 1 3 1 3 1 3 1 3 1 3 1 3 3 3 3 3 3 3 5 3 3 5
   3 5 3 5 3 5 3 5 3 5 5 5 5 5 5 5 6 5 5 6 5 6 5 6 6 5 6 5 6 6 6 6 6 6 6 7
   6 6 7 6 7 6 7 7 6 7 6 7 7 7 6 7 7 7 7 7 7 7 7 7 7))
 (4
  (8 8 8 8 8 8 8 8 8 8 8 8 8 8 9 8 8 8 8 8 8 8 9 8 8 8 8 9 8 8 9 8 8 9 8 9
   8 9 8 9 9 8 9 8 9 9 8 9 9 8 9 9 9 9 9 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9
   9 9 9 9 9 9 9))
 (5
  (5 5 5 5 5 5 6 5 5 5 5 6 5 5 6 5 6 6 6 5 6 5 6 6 6 6 6 6 6 7 6 6 7 6 7 7
   7 6 7 6 7 7 7 7 7 7 7 9 7 7 9 7 9 9 9 7 9 7 9 9 9 9 9 9 9 3 9 9 3 9 3 3
   3 9 3 9 3 3 3 9 3 3 3 3 3 3 3 3 3))
 (6
  (9 9 9 9 9 9 9 9 9 9 9 9 9 10 9 9 9 9 9 9 9 10 9 9 9 9 10 9 9 10 9 9 10
   9 10 9 10 10 9 10 9 10 9 10 10 9 10 10 10 10 10 9 10 10 10 10 10 10 10
   10 10 10 10 10 10 10 10 10 10 10 10 10 10)))</pre>

    <p>This short loop has automatically generated a considerable amount of
      data and made its representation and inclusion in the example
      conceptually concise, easy to enter and modify, and tidy. </p>

    <h4 id="chop">An application of the chop method</h4>
    <p>For this composition, the <code>chop</code> method is employed to break
      the original <code>rthm-seq-palette</code> into fragments for use
      with <code>fibonacci-transitions</code>. (See
      the <a href="./chop.html"><code>chop</code></a> page for a more general
      introduction to the method.) The method is applied here to create
      fragments whose durations are multiples of an eighth note using the
      following arguments, then assigning the
      resulting <code>rthm-seq-palette</code> to the
      variable <code>sl-rsp-chopped</code>:</p>

    <pre class="source">
       (sl-rsp-chopped (chop sl-rsp-orig 
                             '((1 2) (1 1) (2 2)) ; chop points
                             'e)) ; chopping unit</pre>

    <p>The <em>chop points</em> here are stipulated specifically, dividing the
      basis beat of the original material (which is determined by the time
      signature of the original material and is a quarter note in this
      instance) into three fragments, two that are one unit long (one beginning
      and ending on the first eighth of the beat and one beginning and ending
      on the second eighth of the beat), and one that is two units long
      (beginning on the first eighth of the beat and ending on the second
      eighth of the beat). The method applies this chopping pattern
      successively to each beat in the entire
      original <code>rthm-seq-palette</code>, resulting in this example in 36
      fragments, the first twelve of which have the following structure: </p>

    <pre class="source">
;; These are first 12 results of the (print-simple sl-rsp-chopped) function
;; commented out in the source code above. 

rthm-seq 1
(1 4): rest E., note S, 
rthm-seq 2
(1 8): rest 8, 
rthm-seq 3
(1 8): rest S, note S, 
rthm-seq 4
(1 4): rest 32, note 32, note 32, note 32, rest E, 
rthm-seq 5
(1 8): rest 32, note 32, note 32, note 32, 
rthm-seq 6
(1 8): rest 8, 
rthm-seq 7
(1 4): note 32, note 32, rest S, note 32, note 32, note 32, rest 32, 
rthm-seq 8
(1 8): note 32, note 32, rest S, 
rthm-seq 9
(1 8): note 32, note 32, note 32, rest 32, 
rthm-seq 10
(1 4): rest S, note S, note S, rest S, 
rthm-seq 11
(1 8): rest S, note S, 
rthm-seq 12
(1 8): note S, rest S,
etc.</pre>

    <p>The results of the <code>chop</code> method are assigned to the
      variable <code>sl-rsp-chopped</code> and passed to
      the <code>rthm-seq-palette</code>.</p>

    <pre class="source">   :rthm-seq-palette sl-rsp-chopped</pre>

    <p>The individual fragments within the
      resulting <code>rthm-seq-palette</code> are then accessed using
      the <code>fibonacci-transitions</code> function from within
      the <code>rhtm-seq-map</code>, as detailed below.</p>
        
    <h4 id="looping">Combining chop and fibonacci-transitions for<br />
      intra-phrasal looping</h4>
    <h5 id="rsm-and-orch">The :rthm-seq-map and orchestration</h5>
    <p>In the next block of this example, the <code>rthm-seq-map</code> is
      then also generated algorithmically:</p>

    <pre class="source">
   :rthm-seq-map (loop for section in
                      '((((1 3) fl ob ))
                        (((3 4) fl ob cl))
                        (((5 6 7 8) fl ob cl)
                         ((11 12 13 14) bn tb vc cb))
                        (((9 10 11) hn tp))
                        (((15 16 25 26) fl ob vno vnt)
                         ((9 10 13 14) cl hn va)
                         ((3 1 16 3) tp tb)
                         ((12 13 10 11) bn vc cb))
                        (((1 3 4) fl ob cl bn hn tp tb vno vnt va vc cb)))
                    for section-num from 1
                    collect 
                      (list section-num
                            (loop for ins-group in section 
                               appending
                                 (loop with fts =
                                      (loop for ch in (first ins-group) 
                                         collect
                                           (list 1 ch))
                                    for ins in (rest ins-group) 
                                    collect
                                      (list ins
                                            (fibonacci-transitions
                                             (nth (1- section-num)
                                                  num-seqs-list) 
                                             fts))))))</pre>

    <p>In addition to being the code that creates the 
      <em>intra-phrasal looping</em>, this <code>loop</code> also determines
      one aspect of the orchestration for the piece, in that it defines which
      instruments of the ensemble play in each section, and which of those
      instruments are "coupling" each other by playing rhythmically identical
      material.</p>

    <p>The <code>loop</code> passes through a list of nested lists. The first
      level of these contains six lists, each corresponding to one section of
      the piece's section map. The next level of lists determines how many
      separate rhythmic patterns will be simultaneously played in each
      section. Sections 1, 2 and 4, for example, each have only one rhythmic
      element played by all instruments, while section 5 has four rhythmic
      elements played by different instrument groups. The final level
      determines exactly which rhythmic patterns will be played, and which
      instruments will play each of these patterns, by specifying a sublist of
      numbers and a series of player IDs.</p>

    <pre class="source">
      '((((1 3) fl ob))
        (((3 4) fl ob cl))
        (((5 6 7 8) fl ob cl)
         ((11 12 13 14) bn tb vc cb))
        (((9 10 11) hn tp))
        (((15 16 25 26) fl ob vno vnt)
         ((9 10 13 14) cl hn va)
         ((3 1 16 3) tp tb)
         ((12 13 10 11) bn vc cb))
        (((1 3 4) fl ob cl bn hn tp tb vno vnt va vc cb)))</pre>

    <p>The player IDs are taken from the <code>ensemble</code> block. The
      numbers are the IDs of the individual <code>rthm-seq</code> objects
      contained in the <code>rthm-seq-palette</code> created by
      the <code>chop</code> method.</p>

    <h5 id="assembling">Assembling the rthm-seq-map from the chop
      fragments</h5>
    <p>To accommodate for the additional level of nesting that
      the <code>chop</code> method adds to any <code>rthm-seq-palette</code>
      it processes, the loop function here automatically adds the additional ID
      from the original <code>rthm-seq</code> object required to reference each
      given <code>rthm-seq</code> (fragment) that the chopped palette
      contains. Since only one <code>rthm-seq</code> was defined in the
      original <code>rthm-seq-palette</code>, and this was given the
      ID <code>1</code>, the newly created fragments are accessed
      using <code>(1 1)</code>, to get the first fragment
      of <code>rthm-seq</code> <code>1</code>, <code>(1 2)</code> to get the
      second fragment of <code>rthm-seq</code> <code>1</code>,
      <code>(1 3)</code> to get the third fragment
      of <code>rthm-seq</code> <code>1</code>, etc.</p>

    <pre class="source">
      (loop for ch in (first ins-group) 
         collect
           (list 1 ch))</pre>

      
    <p>See the manual page on <a href="./chop.html">chop</a> for more detail on
      this concept.</p>

    <p>The last component of this <code>loop</code> is then a call to
      the <code>fibonacci-transitions</code> function for each of the players
      listed, using the references created from the collection of the
      original <code>rthm-seq</code> ID and the new <code>rthm-seq</code> IDs,
      and the same <code>num-seqs-list</code> used for
      the <code>set-map</code>.</p>

    <pre class="source">
      collect
        (list ins
              (fibonacci-transitions
               (nth (1- section-num) num-seqs-list) 
               fts))))))</pre>
    
    <p>If these were written out in full, they would look like this: </p>

    <pre class="source">
 ((1
   ((fl (fibonacci-transitions 53 '((1 1) (1 3))))
    (ob (fibonacci-transitions 53 '((1 1) (1 3)))))
  (2
   ((fl (fibonacci-transitions 61 '((1 3) (1 4))))
    (ob (fibonacci-transitions 61 '((1 3) (1 4))))
    (cl (fibonacci-transitions 61 '((1 3) (1 4))))))
    etc.</pre>


    <p>All together, then, the code that this <code>loop</code> generates would
      begin like this: </p>
    
    <pre class="source">
((1
  ((FL
    ((1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 3) (1 1)
     (1 1) (1 1) (1 1) (1 3) (1 1) (1 1) (1 3) (1 1) (1 1) (1 3) (1 1)
     (1 3) (1 1) (1 3) (1 1) (1 3) (1 3) (1 1) (1 3) (1 3) (1 1) (1 3)
     (1 3) (1 3) (1 3) (1 3) (1 1) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)
     (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)))
   (OB
    ((1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 1) (1 3) (1 1)
     (1 1) (1 1) (1 1) (1 3) (1 1) (1 1) (1 3) (1 1) (1 1) (1 3) (1 1)
     (1 3) (1 1) (1 3) (1 1) (1 3) (1 3) (1 1) (1 3) (1 3) (1 1) (1 3)
     (1 3) (1 3) (1 3) (1 3) (1 1) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)
     (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)))))
 (2
  ((FL
    ((1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)
     (1 4) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 4) (1 3) (1 3)
     (1 3) (1 3) (1 4) (1 3) (1 3) (1 4) (1 3) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 3) (1 4) (1 4) (1 3) (1 4) (1 4) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)))
   (OB
    ((1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)
     (1 4) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 4) (1 3) (1 3)
     (1 3) (1 3) (1 4) (1 3) (1 3) (1 4) (1 3) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 3) (1 4) (1 4) (1 3) (1 4) (1 4) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)))
   (CL
    ((1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3)
     (1 4) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 3) (1 4) (1 3) (1 3)
     (1 3) (1 3) (1 4) (1 3) (1 3) (1 4) (1 3) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 3) (1 4) (1 4) (1 3) (1 4) (1 4) (1 4) (1 4) (1 4) (1 3)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)
     (1 4) (1 4) (1 4) (1 4) (1 4) (1 4)))))
    etc.</pre>

    <h5 id="equal-lengths">Equal lengths</h5>
    <p>A final reminder must be made before leaving this section. As discussed
      in the <a href="./coreUsage.html">core-usage</a> guide, all
      simultaneously occurring <code>rthm-seq</code> objects in a
      given <code>rthm-seq-map</code> must be of the same length. For example,
      the fifth section from this piece includes fibonacci-based transitions
      from <code>rthm-seq</code> <code>(1 15)</code> to
      <code>(1 16)</code> to <code>(1 25)</code> to <code>(1 26)</code> in
      the <code>fl</code>, <code>ob</code>, <code>vno</code>
      and <code>vnt</code>, against simultaneously occurring transitions
      from <code>rthm-seq</code> <code>(1 3)</code> to <code>(1 1)</code>
      to <code>(1 16)</code> to <code>(1 3)</code> in the <code>tp</code>
      and <code>tb</code>. This only functions without returning an error
      because the corresponding sections are of equal length, thus
      <code>(1 15)</code> and <code>(1 3)</code> both 1/8 bars,
      <code>(1 16)</code> and <code>(1 1)</code> are both 1/4 bars, etc. (This
      holds true for the other simultaneously occurring rhythmic material in
      that section as well.)  </p>
        
    <h3>Calling functions for editing material generated by slippery
      chicken</h3>
    <h4 id="re-bar">re-bar</h4>
    <p>The final method called in this example before generating the output is
      the <code>re-bar</code> method, which re-groups the existing musical
      material into new bars as close to the specified length as possible. The
      chopped material from this example produces only 1/4 and 1/8 bars, so
      re-barring them into larger measures, in this instance, bars that are 4/4
      or larger, will make the resulting music easier to read. That is done by
      calling the <code>re-bar</code> method with the global variable assigned
      to the musical material generated above (<code>+second-law+</code>) and
      specifying the <code>:min-time-sig</code> as <code>'(4 4)</code>. This
      example also turns on the <code>:auto-beam</code> function, setting it to
      automatically beam the newly barred content into quarters
      (<code>'q</code>).</p>

    <pre class="source">
(re-bar +second-law+
        :min-time-sig '(4 4) 
        :auto-beam 'q)</pre>

    <p>As seen here, the <code>re-bar</code> method can be applied outside of
      the above <code>let</code> scope, since the
      <code>slippery-chicken class</code> produces a global variable from its
      first argument.</p>

    <h3>The output</h3>
    <p>The output from this piece is generated in the same manner described in
      the <a href="./coreUsage.html">core-usage</a> guide, with the one
      addition of the <code>:size</code> argument to
      the <code>cmn-display</code> method.</p>
    
    <pre class="source">
;;; midi
(midi-play +second-law+ :midi-file "/tmp/second-law.mid")

;; CMN output
(cmn-display +second-law+ :file "/tmp/second-law.eps" :size 12)

;; LP output
(write-lp-data-for-all +second-law+ :base-path "/tmp/")</pre>

    <p class="nb">NB: <em>slippery chicken</em> has a number of built-in
      algorithms for automatic tidying, such as <code>respell-notes</code>,
      which attempts to automatically choose the best enharmonic spelling of
      pitches in the printed output. The <code>respell-notes</code> algorithm
      is called automatically within the <code>cmn-display</code>
      and <code>write-lp-data-for-all</code> methods. This can be disabled by
      specifying <code>:respell-notes nil</code> in the call
      to <code>cmn-display</code> or <code>write-lp-data-for-all</code>. If the
      user finds that the decisions <em>slippery chicken</em> makes are not in
      line with his or her own preferences, the post-generation editing methods
      can be used to manually tweak the output after the fact, such as by
      changing enharmonic spellings etc. The output for this tutorial has not
      been tweaked. See the page
      on <a href="./post-gen-editing.html">post-generation data editing</a> for
      more on this.</p><br />
    
    <p>The <code>:size</code> argument of the <code>cmn-display</code> method
      scales the size of the music on the page. The use of this argument is
      necessary in this example, as the music would not fit on the page
      otherwise, and the following warning would be issued by 
      <em>slippery chicken</em>. </p>

    <pre class="source">
WARNING:
   we don't have room on the page for this score: try a font size less than 13:</pre>

    <pre class="source">
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; EOF</pre>
    


    <!-- **************************************************************** --> 
    <!-- This spacer <br> is necessary as a buffer between the content and
         the footer. It cannot be added as padding to #push, since #push has to
         be the same size as #footer in order for the dynamic placement to work
         properly --> 
    <br /><br />
    <div id="push"></div>
    </div>
    <script type="text/javascript">footer();</script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
