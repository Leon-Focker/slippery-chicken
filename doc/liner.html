<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>slippery chicken documentation - TEMPLATE</title>
    <!-- change the following two file paths to be ../ if in a subdirectory -->
    <link href="./sc-stylesheet.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="./head-foot.js"></script>
    <script language="javascript" type="text/javascript"
            src="./show-hide.js"></script>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  </head>

  <body onload="showHide(window.location.hash.substring(1)+'-div')" >
    <div id="content">
      <!-- files in the doc directory will call header with argument "./" but
           those in subdirectories will need "../" -->
      <script type="text/javascript">header("./");</script>
      <noscript>Your browser does not support JavaScript!</noscript>
      <!-- **************************************************************** --> 

      <h2>Algorithmic Compositions By Michael Edwards</h2>

      <p>
      <blockquote>
        "Formerly, when one worked alone, at a given point a decision was made,
        and one went in one direction rather than another; whereas, in the case
        of working with another person and with computer facilities, the need
        to work as though decisions were scarce—as though you had to limit
        yourself to one idea—is no longer pressing.  It’s a change from the
        influences of scarcity or economy to the influences of abundance
        and—I’d be willing to say—waste."  (John Cage)
      </blockquote></p>

      <p> As your old maths teacher said about numbers, algorithms are nothing
to be scared of.  Following Descarte's principle of solving difficult problems
by dividing them into smaller, more manageable ones, an algorithm is merely a
step-by-step procedure aimed at solving a particular problem.  The gap between
imagining a new piece of music and realising it in score or any other format is
often bridged by composers in an algorithmic manner, whether explicitly or not.
Algorithmic composition formalises this process and makes it explicit.  It
usually involves the use of a finite set of step-by-step procedures, most often
encapsulated in software routines, to create music.  All the works on this
release, for example, were created by the author with his algorithmic
composition software, "slippery chicken".

                  </p><p>
The formalisation of musical composition is nothing new.  Bach's fugues can be
analysed in terms of their algorithmic properties.  Going further back, to
around 1026, Guido d'Arezzo, the inventor of modern staff notation, developed a
formal technique to set a text to music.  A pitch was assigned to each vowel so
that the melody varied according to the vowels in the text. But the beginnings
of algorithmic composition can be traced even further back, to the ancient
Greeks and the Jewish Kabbalah.

                  </p><p>
What would be the motivation to make music algorithmically?  The explanation
lies at least partly in the cognitive processes involved in experiencing music.
As we listen, we are not merely enjoying the sensual sonic experience of the
moment but setting up expectations of what is to come based on what has already
occurred, not only in the music we are listening to but in other pieces we know
that are similar to it, as well as all the music we have heard thus far
in our lives.  Essentially, using our memory and predictive faculties, we
listeners create musical architecture in our brains, and the more actively we
listen, the more elaborate that architecture becomes.  For centuries then,
composers have taken advantage of this ability to build sonic-structural
relationships in time in order to formalise the compositional process.

                  </p><p>
Formal planning cannot be conflated with algorithmic techniques of course, but
that the former should lead to the latter was a historical inevitability.  The
potential for software algorithms to enrich our musical culture has been
established, in the 50+ years since such techniques were first introduced, by
personalities as diverse as Hiller, Xenakis, Cage, and Eno.  There are many
riches to be mined in algorithmic composition as, amongst other benefits, the
expression of compositional ideas in software often leads to unexpected and
exciting results, and these can seldom be achieved via traditional means.
Algorithmic composition techniques can thus play an energising role in the
development of modern music across all genres and styles.

                  </p><p>
"slippery chicken" can be seen as a bridging technology.  Traditional
composition training in the West does not usually include algorithmic or
computer music techniques, despite the fact that many composers use the
computer regularly in their work.  If the use of algorithmic techniques is to
increase, as the author believes is inevitable, it is essential that bridging
mechanisms are found.  Systems based around or including programming interfaces
to traditional notation are one such solution.  But the programming aspect is
important, as this gives the freedom and flexibility that stimulates
innovation.  Also important is that notation is not the exclusive focus, as
many forms of music do not involve the use of Western musical notation in their
practice.

                  </p><p>
An open-source, specialised algorithmic composition programme written in the
general programming language Common Lisp and its object-oriented extension,
CLOS, "slippery chicken" has been in development since 2000.  By specialised as
opposed to generalised, it is meant that the software was originally
tailor-made to encapsulate the author’s personal composition techniques and to
suit his own compositional needs and goals.  As the software has developed
however, many general-purpose algorithmic composition tools have been
programmed that should be useful to a range of composers.  The system does not
produce music of any particular aesthetic strain; for example, although not
programmed to generate tonal music the system is quite capable of producing it.
Furthermore, the software's release as open-source, object-oriented Common Lisp
code encourages further development and extensions on the part of the user.

                  </p><p>
The algorithmic system in "slippery chicken" has been used to create musical
structure for pieces since its inception and for several years now has been at
the stage where it can generate, in one pass, complete musical scores.  It can
also, with the same data used to generate those scores, write sound files using
samples, or MIDI file realisations of the instrumental score.  The project's
main aim is to facilitate a melding of electronic and instrumental sound
worlds, not just at the sonic but also at the structural level.  Hence certain
processes common in one medium (for instance sound file slicing and looping)
are transferred to another (the slicing up of notated musical phrases and the
instigation of sub-phrase loops, for example).  Techniques for the innovative
combination of rhythm and pitch data—arguably one of the most difficult
aspects of making convincing musical algorithms—are also offered.

</p><p>
Perhaps the debate surrounding the relative merits of analogue versus digital
studio technology have most convincingly shown that combinations of the old and
the new offer the best solutions.  This applies just as well to music
composition and performance.  Formats that continue to include rather than
bypass the talented and highly-trained acoustic musicians which our musical
infrastructure has produced yield the most impact, particularly when viewed,
for better or for worse, from the audience’s perspective.  To this end, hybrid
works combining digital and acoustic instrumental technologies are ideal.
"slippery chicken" is focussed on exactly such musical bridging solutions:
using the computer to combine and meld together electronic and acoustic
resources at both the structural and formal level.

                  </p><p>
Michael Edwards, Edinburgh, May 23rd 2012


      <!-- **************************************************************** --> 
      <!-- This spacer <br> is necessary as a buffer between the content and
           the footer. It cannot be added as padding to #push, since #push has to
           be the same size as #footer in order for the dynamic placement to work
           properly --> 
      <br /><br />
      <div id="push"></div>
    </div>
    <script type="text/javascript">footer();</script>
    <noscript>Your browser does not support JavaScript!</noscript>
  </body>
</html>
